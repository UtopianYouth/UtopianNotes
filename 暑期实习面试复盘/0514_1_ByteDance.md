# 字节跳动抖音基础技术部一面复盘

## 自我介绍

自我介绍真的非常重要，好像每次面试都有，包括影石等，要准备好模板（测试、客户端、后端），这里顺便问了一下到岗时间，实习地点和月数的情况。

## 项目1

**问题1：详细说一下在这个项目中，用到的 IO 多路复用，对比传统的创建一个线程处理一个客户端的 HTTP 请求，你的项目有什么优势吗？**

回答：开始我扭曲了面试官的意思，我把关注点聚焦在了一个线程上面，然后就说通过创建线程池来防止每一个客户端发送了 HTTP 请求就创建一个新的线程，避免了频繁地创建和销毁线程的系统开销。

这里面试官很好，他引导我说 IO 多路复用的优势（其实本质就是想问 IO 多路复用），我回答的比较草率，就说通过用户态下的程序代码，为每一个新到来的客户端 TCP 连接注册 EPOLLIN 事件，然后委托操作系统**内核**检测与客户端通信的 fd 对应 TCP 读缓冲区是否有数据到达，来代替一个线程对应一个客户端请求的方式（<font color = red>这里回答的非常不好，应该从网络编程的监听 fd 入手，详细解释在监听这一步，EPOLL是如何处理客户端的 HTTP 连接的，后续需要复习一下 IO 多路复用的具体实现机制</font>）。

**拓展：IO 多路复用对比传统的 IO 有什么优势？**
从本质来理解，网络 IO 消息处理分为两个阶段：**等待消息到来 & 消息处理**，在两个阶段同时处理的**单 IO 业务逻辑**中，等待消息到来会造成线程阻塞等待，并且频繁的切换线程状态，使得 CPU 资源利用率低下，无法实现高并发。所以，我们需要将**等待消息和消息处理的两个业务逻辑分开**，减少线程的状态切换，充分利用 CPU 资源，实现程序高并发。

IO 多路复用，多路复用指的就是等待消息的线程，**可以同时等待多个连接（让内核监测消息的到来，并且监测的 fd 需要设置非阻塞）**，一旦消息到来，就通知消息处理的线程执行。Linux 内核提供了 IO 多路复用机制，而实现高并发，需要我们自己实现业务逻辑。



**问题2：接着问题 1 继续深入，你刚刚说到了操作系统内核会帮忙检测对应 fd 的缓冲区中是否有数据，来实现与客户端的通信，能说说内核具体是怎么实现的吗？**

回答：这里直接懵了，我第一反应是我好像也没看过 linux 内核源码的实现诶（所以直接老实回答说不太会），为了避免说不太会的尴尬，我尝试回答了内核应该会有检测 TCP 通信缓冲区中是否有数据的代码逻辑，然后基于内核实现的 TCP/IP 协议来与客户端进行数据交互（<font color = red>面试中真的会降智，这个问题虽然本质不会，但是尝试回答的部分应该可以从 TCP 读写缓冲区入手，然后静下心来结合缓冲区说一下具体的 TCP 通信过程，完全是可以做到更好的</font>）。

**拓展：在linux 内核中，EPOLL 具体是如何实现的？**

EPOLL 底层的数据结构实现是**基于红黑树和就绪链表**（两个数据结构之间的数据 copy 是基于指针的，也就是不存在 EPOLL 结构体的拷贝，只是简单的指针赋值），在用户态下每调用一次`epoll_wait()`就从就绪链表中获取发生事件的 fd，然后返回给用户程序。

红黑树存放了注册 EPOLL 事件的 fd，就绪链表存放了发生 EPOLL 事件的 fd。

对于 fd，EPOLL事件（缓冲区）检测主要是通过**网络协议栈和网卡驱动**协同完成的，具体数据流程大致如下：

> 网卡驱动通过 DMA 控制器将数据放入内核环形缓冲区 ==》网卡对CPU发送硬件中断信号，通知有数据到达 ==》转换为软件中断，内核通过网络协议栈解析数据，存入对应的 fd 中 ==》内核唤醒 EPOLL ==》触发 EPOLL 回调函数 ==》将事件加入到就绪队列中 ==》用户态通过 `epoll_wait()` 获取事件 ==》进行逻辑处理。



**问题3：**还是基于问题 1 的深入，因为问题 1 谈到了 OS 的内核，这里面试官就说，你能说一下在日常编程中，使用什么函数会进入内核态吗？

回答：懵了，直接说很常见的 `printf()`，然后直接说会触发 IO 中断。（这里答案没问题，但是回答的不够深入，面试官针对这个问题也没有深入聊下去）

**优化：**调用了 `printf()` 函数之后，在用户态下完成格式化字符串的工作，解析`%s`占位符和`\n`字符等，当解析的过程中遇到了`\n`，程序就会通过系统调用 `write()` 将用户空间下缓冲区的字符串内容写入到内核缓冲区中，然后系统调用会触发 OS 从用户态切换到内核态）。



**问题4：**基于问题 3 的深入，在说一下什么情况下会触发 OS 从用户态切换到内核态（经典“变态”问题）。

回答：感觉也回答的比较浅，直接说了中断、异常和系统调用（比如 linux 编程中的 `read()`和 `send()` 系统调用）。



**问题5：**还是基于问题 3的深入，既然这样的话，你觉得像 `abs()` 相关的函数执行过程中，OS 会进入内核态吗？

回答：太难崩了，当时我内心在想，这么简单的问题，现实生活中我肯定会直接说不会进入到内核态（模糊记忆的驱使，但是如果说为什么不会进入到内核态，我应该答不上来），此时内心斗争了差不多 30s 🤣，感觉有坑，我就想，求绝对值运算，首先从内存中取出变量，然后通过数据总线传入到 CPU 的寄存器中，然后进行绝对值运算...（此时思维已经很混乱了，甚至在想这会触发 CPU 的上下文切换吗，其实就是对计组、程序运行逻辑、用户态和内核态的本质等八股记得不太清楚导致的），最后用不太肯定的语气说了不会进入到内核态，面试官反问一定不会进入内核态吗，我说一定不会（这里还好回答对了，虽然问题很基础，难崩！！）。

细细回忆一下，为什么 `abs()` 不会进入 OS 内核态呢，其实本质就是该函数不需要执行系统调用，并且不存在内核系统资源的访问，也不存在硬件交互。只需要在程序的执行逻辑下，将用户空间内存中存储的变量，传给 CPU 进行运算即可，而 CPU 运算在用户态下就能完成，所以不涉及到变态。

**关键点：**OS只要涉及到与外界硬件资源（内存以外的任何资源）的数据交互，就一定需要**内核**的参与。



**问题6：**回想一下，应该是对问题4的深入，给你线程 A 和线程 B，线程 B 执行的是计算密集型任务，在线程 B 占用 CPU 资源的时候，线程 A 可以抢占线程 B 的 CPU 使用权吗，如果可以抢占，具体是怎么实现的，如果不可以抢占，又是为什么？

回答：还是懵，我第一反应想的是，这不应该是线程调度的问题吗，感觉线程 A 包可以抢占线程 B 的 CPU 使用权呀，然后跟面试官举例子说，如果 OS 的线程调度是基于时间片轮转的，在每一个 TCB 中记录了线程的 CPU 剩余使用时间，然后线程 B 的时间片用完后，CPU 就会继续调度线程 A 。

回答没抓住重点，面试官解释 ==> 我知道你说的意思，但是线程 B 是计算机密集型任务，CPU 很忙，一直在执行计算任务，根本没空去检测每一个 TCB 中剩余的 CPU 使用时间，这种情况应该怎么办。

续答：第二反应，既然软的不行，就来硬的，我说 CPU 工作的时候，有它的时钟周期，可不可以在硬件的层面上（还是基于时间片轮转），当 CPU 执行到指定时钟周期之后，对 CPU 发送硬件中断信号，强制 CPU 去检测指定寄存器里面的值（这个寄存器存放了当前调度线程的剩余 CPU 使用时间），如果剩余时间小于等于 0，就触发线程调度机制。

感觉答的很不好，但是面试官没有后续追问了，应该是时间有限，继续下一个问题了。

**拓展：Linux内核中实现了几种线程调度的方式？**

> 总的来说分为两大类，一类是非实时的，一类是实时的，如下表：
>
> |        策略         |  类型  |                   特点                   |     优先级范围      |       典型场景       |
> | :-----------------: | :----: | :--------------------------------------: | :-----------------: | :------------------: |
> | `SCHED_OTHER` (CFS) | 非实时 | 公平共享，动态时间片，支持 `nice` 值调整 | -20 (高) ~ +19 (低) |  桌面应用、Web 服务  |
> |    `SCHED_BATCH`    | 非实时 |         减少唤醒频率，批处理优化         |  仅受 `nice` 影响   | 编译任务、数据批处理 |
> |    `SCHED_IDLE`     | 非实时 |     最低优先级，仅当 CPU 空闲时运行      |        最低         |     系统后台监控     |
> |    `SCHED_FIFO`     |  实时  | 无时间片，高优先级抢占，同优先级先进先出 |       1 ~ 99        | 工业控制器、紧急响应 |
> |     `SCHED_RR`      |  实时  |    带时间片的 FIFO，同优先级轮转执行     |       1 ~ 99        |  音视频流、通信网关  |
> |  `SCHED_DEADLINE`   |  实时  |     按截止时间调度，严格保证任务时限     | 优先级最高（隐含）  |  自动驾驶、医疗设备  |
>
> CFS(Completely Fair Scheduler)
>
> 查看当前进程的调度策略命令：`chrt -p <PID>`

结合 Linux 的**线程调度策略**，来回答问题 6 会更加清晰一点：

> 可以抢占，但是有条件限制：
> 当线程 A 的优先级大于线程 B 时，可以抢占，优先级计算，
>
> ```shell
> vruntime(A) < vruntime(B) - wakeup_granularity(B)
> ```
>
> 分配给线程 B 的时间片耗尽。
>
> 不可以抢占的情况：
>
> 计算密集型任务线程 B 刚启动，线程 B 的 `vruntime` 增长未超过阈值；
>
> CPU处于高负载，运行队列中都是 `SCHED_BATCH` 任务，内核会延长批量任务组的整体运行时间窗口；
>
> 线程 B 使用了自旋锁。



**问题7：**看你项目 EPOLL 主要用在网络编程的客户端与服务器的数据交互中，那么在 linux 系统编程中，涉及到的进程或者线程通信，比如管道、信号、共享内存等，因为管道也是基于 fd 实现的嘛，也可以使用 IO 多路复用吗？

回答：我应该是听到了 fd 关键字，回想一下 EPOLL 的本质就是通过内核监听对应 fd 发生的事件（EPOLLIN、EPOLLOUT等），我直接肯定的回答说也可以通过 IO 多路复用实现，但是好像这里只有管道是基于 fd 的🤣。（<font color = red>其实在 webserver 项目中，有用到 EPOLL 监听管道的读端，管道的写端读取 OS 给进程发送的信号，实现了进程结束和定时器功能</font>）

应该是没有回答完全错，但是面试官没有详细问了，这个问题反映了，需要弄清楚 EPOLL 的本质就是基于 fd 的，只要是 fd，就可以用 EPOLL 注册监听的事件，并且委托内核检测之。然后就是，需要巩固 IPC 的八股内容。

**问题8：**HTTP 协议和 HTTPS 协议的区别？

HTTPS 在进行通信之前，有进行 TLS 握手，保证数据传输的安全性。

## **手撕题目**

很幸运，抽到了 LC mid 原题，寻找数组中第 k 大的元素，直接小根堆，O(n) 的时间复杂度秒了。

面试官反问：用优先队列空间复杂度太高了，有没有空间复杂度不是那么高的思路，这里我的第一反应是改进快排，因为快排的每一次分治之前，都可以唯一确定一个基准所在的位置，所以，在快排的基础上，对确定基准的索引和第 k 大元素索引进行比较，如果相等，说明找到了，就不用继续分治了。

这里面试官说这个方法可以尝试一下，让我手撕写出来（真的给自己菜无语了，快排很久没写了，边界条件忘记了，然后写的非常的坎坷）。

手撕完后，面试官让我用自己的 IDE 调试去找bug，看下是哪里出错了，并且给出了优化思路，就是每次分治都只要确定 k 所在的那一部分基准即可。找了很久，还是只能过部分样例，面试官让我线下去考虑一下边界条件，最后发现就是一个等于号的问题，当时没发现（真的感觉遇到了神仙面试官，太友好了，面试体验不错）。

<font color = red>复习一下手撕快排！！！</font>

