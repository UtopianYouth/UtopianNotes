# 云鲸智能机器人开发一面复盘

#### 自我介绍

自我介绍真的非常重要，好像每次面试都有，包括影石等，要准备好模板（测试、客户端、后端）。

这个面试考察的项目内容比较多。

#### 从项目1入手：轻量级多线程web服务器

**问题1：**说一下项目中管道主要的作用？

这里我回答错了，一紧张说是主线程和线程池中的线程通信的（好离谱啊/(ㄒoㄒ)/~~），在webserver项目中，用到了匿名管道，进程捕捉的信号发送到管道写端，然后从管道读端读取捕捉的信号。

> 项目中只对 SIGTERM 和 SIGALRM 注册了信号处理函数
>
> 读端读取如下信号：
>
> - SIGTERM：结束进程运行；
> - SIGALRM：执行定时器的 tick() 函数，检查到期的 TCP 连接，并且调用 alarm() 函数再次发送 SIGALRM 信号，程序在一段时间间隔后，再次执行定时器的 tick() 信号。

**问题2：**线程池是自己写的吗，是的话简单介绍一下怎么实现的？

这里提醒了我，线程池要好好复习，虽然项目是跟着视频做的，但是只能硬着头皮说是自己写的，接着面试官说线程池具体都封装了哪些东西，大概介绍一下。

> 下次遇到这个问题，先把线程池最重要的部分答出来：
>
> 重要的成员变量：
>
> - 线程数组和线程数量
> - 工作队列（线程池中的线程互斥访问的共享资源）
> - 互斥量和信号量
> - 线程退出标识变量
>
> 重要的成员方法：
>
> - append() 方法，主线程调用，往工作队列中添加指定任务类对象
> - run() 方法，线程池中线程的逻辑函数，从工作队列中取出任务类对象

**问题3：**线程池中工作队列存储的是什么？

这里没什么好说的，我就说存储了 HTTP 任务类对象，通过任务类对象解析客户端发送过来的 HTTP 请求，然后写对应的 HTTP 响应。

**问题4：**接着问题3的深入，HTTP 任务类对象都有哪些内容？

这个问题没啥毛病，考察对项目的深入了解，答的不是很好，这里也需要做一下简单的总结：

> 重要的成员变量：
>
> - 客户端信息相关
>   - 与客户端通信的 socket_addr 
>   - socket_addr 对应的 fd
> - 读缓冲区相关
>   - 存储 HTTP 请求数据的 readbuf，字符数组，大小有限制
>   - 记录读取数据的最后一个索引
>
> - 解析 HTTP 请求相关
>   - 当前正在解析行的起始位置
>   - 当前正在解析字符在读缓冲区的位置
> - 写缓冲区相关
>   - 存储 HTTP 响应的 writebuf，字符数组，大小有限制
>   - 待发送的字节数（因为可能涉及到多次发送）
>   - 已发送的字节数
> - 解析 HTTP 请求的相关参数
>   - url、connection、http 版本等
> - 响应文件相关
>   - 目标文件内存映射到的内存起始位置，目标文件状态等
>
> 重要的成员方法（根据程序执行流程来）：
>
> - read()：主线程 epoll_wait() 检测到客户端发送的 HTTP 请求，通过 recv() 系统调用，将 HTTP 请求的数据从 TCP 内核缓冲区拷贝到 HTTP 任务类对象的用户缓冲区中，<font color = red>主线程执行完 read() 函数后，将客户端对应的 HTTP 任务类对象添加到线程池的工作队列中</font>
> - process()：线程池中的线程通过执行 run() 方法，从工作队列中取出一个 HTTP 任务类对象，执行任务类对象的 process() 方法
>   - processRead()：通过解析 readbuf 中存储的 HTTP 请求数据，得到解析的结果，并且定位 HTTP 请求的资源
>     - getReuqestFile()：将 HTTP 请求的资源通过内存映射，从磁盘映射到用户空间中
>   - processWrite()：将 HTTP 响应头、响应行和响应体（用户空间的映射资源）拼接到 writebuf 中。写响应成功，修改内核监听与客户端通信 fd 的事件为 EPOLLOUT
> - write()：主线程 epoll_wait() 检测与客户端通信的 fd 的 TCP 写缓冲区可写，通过 writev() 分散写系统调用，将任务类对象用户缓冲区的内容拷贝到 TCP 通信的内核缓冲区中，由 OS 内核将 HTTP 响应的数据发送给客户端。

**问题5：**关于 vector 的扩容和释放，释放没有想过啊😟？

扩容答的也不是很有逻辑，记得当时的回答应该是：当 vector 数组容量满了之后，继续调用 push_back() 或者 emplace_back() 时，就会发生扩容，扩容是按原来的 2 倍容量扩容（不知道这个数字对不对），然后因为不是原地扩容，会存在内存拷贝的系统开销（我这里说了一下应该可以用c++11新特性的移动语义来避免扩容的内存拷贝，不知道对不对），释放直接 g 了，没答出来，简单的说了一下，使用 pop_back() 不会导致 vector 容量的减小（也就是释放）。

关于扩容：

关于释放：`shrink_to_fit()`

**问题6：**线程池可以做到泛化吗，也就是线程的工作函数怎么做到泛化？

是可以泛化的，而且项目也确实做到了泛化，也就是任务类对象通过实现 process() 方法，处理自己的业务逻辑，交给线程池中的线程逻辑函数 run() 调用就可以了，参考问题3和问题4的项目运行逻辑。

罢了，这个问题问的很好，也有解救的机会，可惜因为对项目用到的线程池没有很好地复习，一开始的问题2就答错了，以为任务类对象 process() 方法的具体实现是在线程的 run() 方法中。

虽然只有短短的 20 mins，貌似收获也还行诶。
