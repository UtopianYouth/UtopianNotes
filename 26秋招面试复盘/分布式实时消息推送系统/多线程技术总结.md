# åˆ†å¸ƒå¼èŠå¤©å®¤é¡¹ç›® - C++11å¤šçº¿ç¨‹æŠ€æœ¯æ€»ç»“

## ç›®å½•
- [ä¸€ã€é¡¹ç›®æ¶æ„æ¦‚è§ˆ](#ä¸€é¡¹ç›®æ¶æ„æ¦‚è§ˆ)
- [äºŒã€Cometå±‚å¤šçº¿ç¨‹è®¾è®¡](#äºŒcometå±‚å¤šçº¿ç¨‹è®¾è®¡)
- [ä¸‰ã€Jobå±‚å¤šçº¿ç¨‹è®¾è®¡](#ä¸‰jobå±‚å¤šçº¿ç¨‹è®¾è®¡)
- [å››ã€Logicå±‚å¤šçº¿ç¨‹è®¾è®¡](#å››logicå±‚å¤šçº¿ç¨‹è®¾è®¡)
- [äº”ã€Muduoç½‘ç»œåº“æ ¸å¿ƒå¤šçº¿ç¨‹æœºåˆ¶](#äº”muduoç½‘ç»œåº“æ ¸å¿ƒå¤šçº¿ç¨‹æœºåˆ¶)
- [å…­ã€C++11å¤šçº¿ç¨‹æŠ€æœ¯æ€»è§ˆ](#å…­c11å¤šçº¿ç¨‹æŠ€æœ¯æ€»è§ˆ)
- [ä¸ƒã€é¢è¯•è¦ç‚¹é€ŸæŸ¥](#ä¸ƒé¢è¯•è¦ç‚¹é€ŸæŸ¥)

---

## ä¸€ã€é¡¹ç›®æ¶æ„æ¦‚è§ˆ

### 1.1 ä¸‰å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Client (WebSocket)                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Comet Layer (chat-room)                            â”‚
â”‚  - ç»´æŠ¤WebSocketé•¿è¿æ¥                               â”‚
â”‚  - HTTP/WebSocketæœåŠ¡                                â”‚
â”‚  - gRPCæœåŠ¡æ¥æ”¶æ¨é€                                  â”‚
â”‚  - å¤šçº¿ç¨‹EventLoop + ä¸šåŠ¡çº¿ç¨‹æ±                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ Kafka + gRPC
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Job Layer                                           â”‚
â”‚  - æ¶ˆè´¹Kafkaæ¶ˆæ¯é˜Ÿåˆ—                                 â”‚
â”‚  - å¼‚æ­¥æ¨é€åˆ°Cometå±‚                                 â”‚
â”‚  - ThreadPool + EventLoop                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ HTTP API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Logic Layer                                         â”‚
â”‚  - HTTP APIä¸šåŠ¡å¤„ç†                                  â”‚
â”‚  - MySQL + Redisè¿æ¥æ±                                â”‚
â”‚  - å¤šçº¿ç¨‹EventLoop                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€Cometå±‚å¤šçº¿ç¨‹è®¾è®¡

### 2.1 å¤šçº¿ç¨‹åœºæ™¯è¯¦è§£

#### åœºæ™¯1ï¸âƒ£ï¼šMuduo Reactorå¤šçº¿ç¨‹ç½‘ç»œI/O

**ä»£ç ä½ç½®**: `server/application/chat-room/main.cc:138`

```cpp
m_server.setThreadNum(m_config.num_event_loops);
```

**è®¾è®¡åŸç†**:
- **One Loop Per Threadæ¨¡å‹**
  - ä¸»çº¿ç¨‹EventLoop: è´Ÿè´£Acceptæ–°è¿æ¥
  - å­çº¿ç¨‹EventLoop: å¤„ç†å·²å»ºç«‹è¿æ¥çš„è¯»å†™äº‹ä»¶
  - Round-Robinè´Ÿè½½å‡è¡¡: æ–°è¿æ¥è½®æµåˆ†é…ç»™å„ä¸ªå­çº¿ç¨‹

**ä¸ºä»€ä¹ˆä½¿ç”¨å¤šçº¿ç¨‹ï¼Ÿ**
```
å•çº¿ç¨‹ç“¶é¢ˆ:
  Accept â†’ Read â†’ Parse â†’ Process â†’ Write
  â””â”€ ä¸€ä¸ªè¿æ¥é˜»å¡ï¼Œæ‰€æœ‰è¿æ¥ç­‰å¾…

å¤šçº¿ç¨‹ä¼˜åŠ¿:
  ä¸»çº¿ç¨‹: Accept â†’ åˆ†å‘
  çº¿ç¨‹1: Conn1(Read/Write) + Conn4(Read/Write) + ...
  çº¿ç¨‹2: Conn2(Read/Write) + Conn5(Read/Write) + ...
  çº¿ç¨‹3: Conn3(Read/Write) + Conn6(Read/Write) + ...
  â””â”€ å……åˆ†åˆ©ç”¨å¤šæ ¸CPUï¼Œæé«˜å¹¶å‘èƒ½åŠ›
```

**æ€§èƒ½å¯¹æ¯”**:
| æ¨¡å‹ | æœ€å¤§å¹¶å‘è¿æ¥ | CPUåˆ©ç”¨ç‡ | å»¶è¿Ÿ |
|------|-------------|----------|------|
| å•çº¿ç¨‹EventLoop | ~5000 | 25% (å•æ ¸) | é«˜ |
| 4çº¿ç¨‹EventLoop | ~20000 | 90% (4æ ¸) | ä½ |

---

#### åœºæ™¯2ï¸âƒ£ï¼šä¸šåŠ¡å¤„ç†çº¿ç¨‹æ± ï¼ˆè®¡ç®—å¯†é›†å‹ä»»åŠ¡ï¼‰

**ä»£ç ä½ç½®**: `server/application/chat-room/main.cc:148, 202-208`

```cpp
// åˆå§‹åŒ–çº¿ç¨‹æ± 
CWebSocketConn::InitThreadPool(m_config.num_threads);

// æ¶ˆæ¯å¤„ç†åˆ†æ´¾
if (m_config.num_threads > 0) {
    // æŠ•é€’åˆ°çº¿ç¨‹æ± 
    m_thread_pool.run(std::bind(&HttpHandler::OnRead, http_handler, buf));
} else {
    // åœ¨I/Oçº¿ç¨‹ç›´æ¥å¤„ç†
    http_handler->OnRead(buf);
}
```

**ä¸ºä»€ä¹ˆéœ€è¦ä¸šåŠ¡çº¿ç¨‹æ± ï¼Ÿ**

| ä»»åŠ¡ç±»å‹ | å¤„ç†ä½ç½® | åŸå›  |
|---------|---------|------|
| ç½‘ç»œæ•°æ®æ”¶å‘ | EventLoopçº¿ç¨‹ | éœ€è¦å¿«é€Ÿå“åº”ï¼Œä¸èƒ½é˜»å¡ |
| WebSocketæ¡æ‰‹è§£æ | çº¿ç¨‹æ±  | CPUå¯†é›†ï¼Œè€—æ—¶è¾ƒé•¿ |
| JSONè§£æ | çº¿ç¨‹æ±  | åºåˆ—åŒ–/ååºåˆ—åŒ–æ¶ˆè€—CPU |
| ä¸šåŠ¡é€»è¾‘åˆ¤æ–­ | çº¿ç¨‹æ±  | é¿å…é˜»å¡ç½‘ç»œI/O |

**æ¶æ„å›¾**:
```
EventLoopçº¿ç¨‹1       ä¸šåŠ¡çº¿ç¨‹æ± 
   â”‚                    â”‚
   â”œâ”€ Conn1 æ•°æ®åˆ°è¾¾    â”‚
   â”‚   â””â”€ è¯»å–æ•°æ®      â”‚
   â”‚      â””â”€ æŠ•é€’ â”€â”€â”€â”€â”€â–ºâ”‚â”€â”€ Worker1: è§£æå¤„ç†
   â”‚                    â”‚
   â”œâ”€ Conn2 æ•°æ®åˆ°è¾¾    â”‚
   â”‚   â””â”€ è¯»å–æ•°æ®      â”‚
   â”‚      â””â”€ æŠ•é€’ â”€â”€â”€â”€â”€â–ºâ”‚â”€â”€ Worker2: è§£æå¤„ç†
   â”‚                    â”‚
   â””â”€ Conn3 å¯å†™        â”‚
       â””â”€ å‘é€å“åº” â—„â”€â”€â”€â”€â”´â”€â”€ Worker3: å¤„ç†å®Œæˆ
```

---

#### åœºæ™¯3ï¸âƒ£ï¼šgRPCæœåŠ¡ç‹¬ç«‹çº¿ç¨‹

**ä»£ç ä½ç½®**: `server/application/chat-room/main.cc:380-382`

```cpp
std::thread grpc_thread([&grpc_server]() {
    grpc_server->Wait();  // é˜»å¡ç­‰å¾…gRPCè¯·æ±‚
});
```

**ä¸ºä»€ä¹ˆéœ€è¦ç‹¬ç«‹çº¿ç¨‹ï¼Ÿ**
- gRPCæœåŠ¡ï¼ˆæ¥æ”¶Jobå±‚æ¨é€ï¼‰ä¸HTTP/WebSocketæœåŠ¡**äº’ä¸å¹²æ‰°**
- `Wait()`æ˜¯é˜»å¡è°ƒç”¨ï¼Œä¸èƒ½å ç”¨EventLoopä¸»çº¿ç¨‹
- gRPCå†…éƒ¨æœ‰è‡ªå·±çš„çº¿ç¨‹æ± å¤„ç†å¹¶å‘è¯·æ±‚

---

### 2.2 çº¿ç¨‹åŒæ­¥æœºåˆ¶è¯¦è§£

#### åŒæ­¥ç‚¹1ï¸âƒ£ï¼šConnectionManager - è¯»å†™é”ï¼ˆshared_mutexï¼‰

**ä»£ç ä½ç½®**: `server/application/chat-room/main.cc:36-67`

```cpp
class ConnectionManager {
    std::atomic<uint32_t> m_next_id{1};  // âœ… åŸå­æ“ä½œç”ŸæˆID
    std::unordered_map<uint32_t, HttpHandlerPtr> m_connections;
    mutable std::shared_mutex m_mutex;    // âœ… è¯»å†™é”

public:
    uint32_t AddConnection(const HttpHandlerPtr& handler) {
        uint32_t id = m_next_id.fetch_add(1);  // âš¡ æ— é”åŸå­é€’å¢
        std::unique_lock<std::shared_mutex> lock(m_mutex);  // ğŸ”’ å†™é”
        m_connections[id] = handler;
        return id;
    }

    HttpHandlerPtr GetConnection(uint32_t id) {
        std::shared_lock<std::shared_mutex> lock(m_mutex);  // ğŸ”“ è¯»é”ï¼ˆå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»ï¼‰
        auto it = m_connections.find(id);
        return (it != m_connections.end()) ? it->second : nullptr;
    }
};
```

**ä¸ºä»€ä¹ˆç”¨shared_mutexï¼Ÿ**

| é”ç±»å‹ | è¯»æ“ä½œ | å†™æ“ä½œ | é€‚ç”¨åœºæ™¯ |
|--------|-------|-------|---------|
| `std::mutex` | äº’æ–¥ï¼ˆä¸€æ¬¡åªèƒ½ä¸€ä¸ªçº¿ç¨‹ï¼‰ | äº’æ–¥ | è¯»å†™å‡è¡¡ |
| `std::shared_mutex` | å…±äº«ï¼ˆå¤šä¸ªçº¿ç¨‹å¯åŒæ—¶è¯»ï¼‰ | äº’æ–¥ | è¯»å¤šå†™å°‘ âœ… |

**æ€§èƒ½å¯¹æ¯”ï¼ˆ1000æ¬¡æŸ¥è¯¢ + 10æ¬¡æ’å…¥ï¼‰**:
```
std::mutex:         è€—æ—¶ 150ms ï¼ˆæ‰€æœ‰æ“ä½œä¸²è¡Œï¼‰
std::shared_mutex:  è€—æ—¶ 20ms  ï¼ˆè¯»æ“ä½œå¹¶è¡Œï¼‰
```

---

#### åŒæ­¥ç‚¹2ï¸âƒ£ï¼šPubSubService - æˆ¿é—´è®¢é˜…ç®¡ç†

**ä»£ç ä½ç½®**: `server/application/chat-room/service/pub_sub_service.h:36, 100-111`

```cpp
class PubSubService {
    std::mutex room_topic_map_mutex;
    std::unordered_map<string, RoomTopicPtr> room_topic_map;

public:
    void PubSubMessage(const string& room_id, PubSubCallback callback) {
        std::unordered_set<string> user_ids;
        {
            // âœ… ç¼©å°é”çš„èŒƒå›´ï¼šåªåœ¨æ‹·è´æ•°æ®æ—¶æŒæœ‰é”
            std::lock_guard<std::mutex> lock(room_topic_map_mutex);
            if (room_topic_map.find(room_id) == room_topic_map.end()) {
                return;
            }
            user_ids = room_topic_map[room_id]->GetSubscribers();
        }  // ğŸ”“ é”åœ¨æ­¤é‡Šæ”¾

        // âš¡ å›è°ƒæ‰§è¡Œä¸æŒæœ‰é”ï¼Œé¿å…æ­»é”å’Œæ€§èƒ½ç“¶é¢ˆ
        callback(user_ids);
    }
};
```

**å…³é”®è®¾è®¡ç‚¹**:
1. **RAIIè‡ªåŠ¨ç®¡ç†**: `lock_guard`ç¦»å¼€ä½œç”¨åŸŸè‡ªåŠ¨è§£é”
2. **æœ€å°åŒ–é”ç²’åº¦**: å…ˆæ‹·è´æ•°æ®ï¼Œè§£é”åå†æ‰§è¡Œè€—æ—¶çš„å›è°ƒ
3. **é¿å…æ­»é”**: å›è°ƒæœŸé—´ä¸æŒæœ‰é”ï¼Œé˜²æ­¢å›è°ƒä¸­å†æ¬¡åŠ é”å¯¼è‡´æ­»é”

#### åŒæ­¥ç‚¹3ï¸âƒ£ï¼šå…¨å±€WebSocketè¿æ¥æ˜ å°„è¡¨

**ä»£ç ä½ç½®**: `server/application/chat-room/websocket_conn.cc:22-23`

```cpp
// å…¨å±€å˜é‡ï¼ˆå¤šä¸ªçº¿ç¨‹å…±äº«ï¼‰
std::unordered_map<string, CHttpConnPtr> s_user_ws_conn_map;
std::mutex s_mtx_user_ws_conn_map;
```

**ä½¿ç”¨åœºæ™¯**: `server/application/chat-room/rpc/comet_service.cc:100-116`

```cpp
grpc::Status CometServiceImpl::Broadcast(...) {
    std::string ws_frame = BuildWebSocketFrame(message_json, 0x01);

    {
        std::lock_guard<std::mutex> lock(s_mtx_user_ws_conn_map);  // ğŸ”’
        for (const auto& user_pair : s_user_ws_conn_map) {
            CHttpConnPtr ws_conn_ptr = user_pair.second;
            if (ws_conn_ptr) {
                ws_conn_ptr->send(ws_frame);  // å‘é€æ¶ˆæ¯
            }
        }
    }  // ğŸ”“ è‡ªåŠ¨è§£é”

    return grpc::Status::OK;
}
```

**ä¸ºä»€ä¹ˆéœ€è¦é”ï¼Ÿ**
- **gRPCçº¿ç¨‹** (æ¥æ”¶Jobæ¨é€) è¯»å–æ˜ å°„è¡¨å‘é€æ¶ˆæ¯
- **EventLoopçº¿ç¨‹** (å¤„ç†WebSocket) å¢åˆ æ˜ å°„è¡¨å…ƒç´ 
- **ç«æ€æ¡ä»¶**: åŒæ—¶è¯»å†™`unordered_map`ä¼šå¯¼è‡´å´©æºƒ

## ä¸‰ã€Jobå±‚å¤šçº¿ç¨‹è®¾è®¡

### 3.1 å¤šçº¿ç¨‹åœºæ™¯

#### åœºæ™¯1ï¸âƒ£ï¼šThreadPoolå¤„ç†Kafkaæ¶ˆæ¯æ¶ˆè´¹

**ä»£ç ä½ç½®**: `server/application/job/main.cc:165-227`

```cpp
EventLoop loop;
ThreadPool threadPool("KafkaThreadPool");
threadPool.start(4);  // âœ… å¯åŠ¨4ä¸ªå·¥ä½œçº¿ç¨‹

// æŠ•é€’Kafkaæ¶ˆè´¹ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
threadPool.run([&]() {
    while (true) {
        std::string message = consumer.consume();  // ğŸ”´ é˜»å¡è°ƒç”¨
        if (!message.empty()) {
            // è§£æprotobufæ¶ˆæ¯
            ChatRoom::Job::PushMsg pushMsg;
            if (pushMsg.ParseFromString(message)) {
                // é€šè¿‡gRPCæ¨é€åˆ°Cometå±‚
                auto client = CometManager::getInstance().getClient();
                if (pushMsg.type() == BROADCAST) {
                    client->broadcast(pushMsg.msg());
                } else {
                    client->broadcastRoom(pushMsg.room(), pushMsg.msg());
                }
            }
        }
    }
});

loop.loop();  // ä¸»çº¿ç¨‹è¿è¡ŒEventLoopï¼ˆå¯ç”¨äºå®šæ—¶ä»»åŠ¡ç­‰ï¼‰
```

**ä¸ºä»€ä¹ˆéœ€è¦çº¿ç¨‹æ± ï¼Ÿ**

| ä»»åŠ¡ | ç‰¹æ€§ | å¤„ç†æ–¹å¼ |
|------|------|---------|
| Kafkaæ¶ˆè´¹ | é˜»å¡æ“ä½œ | ç‹¬ç«‹çº¿ç¨‹ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹ |
| Protobufè§£æ | CPUå¯†é›† | çº¿ç¨‹æ± å¹¶å‘å¤„ç† |
| gRPCè°ƒç”¨ | ç½‘ç»œI/O | å¼‚æ­¥RPCï¼Œé¿å…é˜»å¡ |

### 3.2 çº¿ç¨‹åŒæ­¥æœºåˆ¶

#### å•ä¾‹æ¨¡å¼çš„çº¿ç¨‹å®‰å…¨

**ä»£ç ä½ç½®**: `server/application/job/main.cc:141-161`

```cpp
class CometManager {
public:
    static CometManager& getInstance() {
        static CometManager instance;  // âœ… C++11ä¿è¯çº¿ç¨‹å®‰å…¨
        return instance;
    }

private:
    CometManager() = default;  // ç§æœ‰æ„é€ 
    std::unique_ptr<CometClient> m_client;
};
```

**C++11çº¿ç¨‹å®‰å…¨ä¿è¯**:
```cpp
// C++11ä¹‹å‰ï¼ˆä¸å®‰å…¨ï¼‰
CometManager* instance = nullptr;
if (instance == nullptr) {  // âŒ å¤šä¸ªçº¿ç¨‹å¯èƒ½åŒæ—¶é€šè¿‡æ£€æŸ¥
    instance = new CometManager();  // âŒ å¯èƒ½åˆ›å»ºå¤šä¸ªå®ä¾‹
}

// C++11ä¹‹åï¼ˆå®‰å…¨ï¼‰
static CometManager instance;  // âœ… ç¼–è¯‘å™¨ä¿è¯åªåˆå§‹åŒ–ä¸€æ¬¡
```

**åŸç†**: ç¼–è¯‘å™¨åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶ä½¿ç”¨ç±»ä¼¼`std::call_once`çš„æœºåˆ¶ç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡ã€‚

## å››ã€Logicå±‚å¤šçº¿ç¨‹è®¾è®¡

### 4.1 å¤šçº¿ç¨‹åœºæ™¯

#### Muduoå¤šçº¿ç¨‹EventLoop

**ä»£ç ä½ç½®**: `server/application/logic/main.cc:89`

```cpp
server_.setThreadNum(config_.num_event_loops);
```

**åŸå› **: ä¸Cometå±‚ç›¸åŒï¼Œå¤„ç†å¤§é‡å¹¶å‘HTTPè¯·æ±‚ã€‚

### 4.2 çº¿ç¨‹åŒæ­¥æœºåˆ¶

#### åŒæ­¥ç‚¹1ï¸âƒ£ï¼šMySQLè¿æ¥æ± ï¼ˆç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼‰

**ä»£ç ä½ç½®**: `server/application/logic/mysql/db_pool.h:109-144`

```cpp
class CDBPool {
private:
    std::mutex mutex_;
    std::condition_variable cond_var_;  // âœ… æ¡ä»¶å˜é‡
    list<CDBConn*> free_list_;          // ç©ºé—²è¿æ¥
    list<CDBConn*> used_list_;          // ä½¿ç”¨ä¸­çš„è¿æ¥
    int db_cur_conn_cnt_;
    int db_max_conn_cnt_;

public:
    CDBConn* GetDBConn(const int timeout_ms = 0) {
        std::unique_lock<std::mutex> lock(mutex_);

        // ç­‰å¾…ç©ºé—²è¿æ¥
        while (free_list_.empty() && db_cur_conn_cnt_ >= db_max_conn_cnt_) {
            if (timeout_ms > 0) {
                cond_var_.wait_for(lock, std::chrono::milliseconds(timeout_ms));
            } else {
                cond_var_.wait(lock);  // âœ… é˜»å¡ç­‰å¾…ï¼Œé‡Šæ”¾é”
            }
        }

        CDBConn* conn = nullptr;
        if (!free_list_.empty()) {
            conn = free_list_.front();
            free_list_.pop_front();
            used_list_.push_back(conn);
        } else if (db_cur_conn_cnt_ < db_max_conn_cnt_) {
            conn = new CDBConn(this);
            used_list_.push_back(conn);
            db_cur_conn_cnt_++;
        }
        return conn;
    }

    void RelDBConn(CDBConn* conn) {
        std::unique_lock<std::mutex> lock(mutex_);
        used_list_.remove(conn);
        free_list_.push_back(conn);
        cond_var_.notify_one();  // âœ… å”¤é†’ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹
    }
};
```

**ä¸ºä»€ä¹ˆç”¨æ¡ä»¶å˜é‡ï¼Ÿ**

å¯¹æ¯”ä¸‰ç§ç­‰å¾…æ–¹å¼:

| æ–¹å¼ | ä»£ç  | CPUå ç”¨ | å“åº”å»¶è¿Ÿ |
|------|------|---------|---------|
| **å¿™ç­‰ï¼ˆBusy Waitï¼‰** | `while (free_list_.empty()) {}` | 100% ğŸ”´ | 0ms |
| **ç¡çœ è½®è¯¢** | `while (free_list_.empty()) { sleep(10ms); }` | 10% ğŸŸ¡ | 0-10ms |
| **æ¡ä»¶å˜é‡ âœ…** | `cond_var_.wait(lock)` | 0% ğŸŸ¢ | 0ms |

**å·¥ä½œæµç¨‹**:
```
çº¿ç¨‹A: GetDBConn()
   â””â”€ è·å–é”
   â””â”€ æ£€æŸ¥free_listä¸ºç©º && è¾¾åˆ°æœ€å¤§è¿æ¥æ•°
   â””â”€ cond_var_.wait(lock)  ğŸ”´ é˜»å¡ï¼Œé‡Šæ”¾é”
        â”‚
        â–¼ çº¿ç¨‹Bæ‰§è¡Œ...
        â”‚
çº¿ç¨‹B: RelDBConn(conn)
   â””â”€ è·å–é”
   â””â”€ å½’è¿˜è¿æ¥åˆ°free_list
   â””â”€ cond_var_.notify_one()  ğŸŸ¢ å”¤é†’çº¿ç¨‹A
        â”‚
        â–¼
çº¿ç¨‹A: è¢«å”¤é†’ï¼Œé‡æ–°è·å–é”
   â””â”€ ä»free_listå–å‡ºè¿æ¥
   â””â”€ è¿”å›è¿æ¥
```

---

#### åŒæ­¥ç‚¹2ï¸âƒ£ï¼šRAIIè‡ªåŠ¨å½’è¿˜è¿æ¥

**ä»£ç ä½ç½®**: `server/application/logic/mysql/db_pool.h:168-184`

```cpp
class AutoRelDBCon {
public:
    AutoRelDBCon(CDBManager* manger, CDBConn* conn)
        : manger_(manger), conn_(conn) {}

    ~AutoRelDBCon() {
        if (manger_) {
            manger_->RelDBConn(conn_);  // âœ… ææ„æ—¶è‡ªåŠ¨å½’è¿˜
        }
    }

private:
    CDBManager* manger_;
    CDBConn* conn_;
};

#define AUTO_REL_DBCONN(m, c) AutoRelDBCon autoreldbconn(m, c)
```

**ä½¿ç”¨ç¤ºä¾‹**:
```cpp
void QueryUser(const string& user_id) {
    CDBManager* db_mgr = CDBManager::getInstance();
    CDBConn* conn = db_mgr->GetDBConn("dbpool");
    AUTO_REL_DBCONN(db_mgr, conn);  // âœ… æ ˆä¸Šå¯¹è±¡ï¼Œè‡ªåŠ¨ç®¡ç†

    // æ‰§è¡ŒæŸ¥è¯¢
    CResultSet* rs = conn->ExecuteQuery("SELECT * FROM users WHERE id = ?");
    // ...

    // âœ… å‡½æ•°è¿”å›æ—¶ï¼Œautoreldbconnææ„ï¼Œè‡ªåŠ¨å½’è¿˜è¿æ¥
    // âœ… å³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œä¹Ÿä¼šæ­£ç¡®å½’è¿˜
}
```

**RAIIä¼˜åŠ¿**:
- é˜²æ­¢å¿˜è®°å½’è¿˜è¿æ¥å¯¼è‡´çš„èµ„æºæ³„æ¼
- å¼‚å¸¸å®‰å…¨ï¼šå³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œææ„å‡½æ•°ä»ä¼šæ‰§è¡Œ

---

#### åŒæ­¥ç‚¹3ï¸âƒ£ï¼šRedisè¿æ¥æ± 

**ä»£ç ä½ç½®**: `server/application/logic/redis/cache_pool.h:150-152`

æœºåˆ¶ä¸MySQLè¿æ¥æ± å®Œå…¨ç›¸åŒï¼š
```cpp
std::mutex m_mutex;
std::condition_variable cond_var_;
```

## äº”ã€Muduoç½‘ç»œåº“æ ¸å¿ƒå¤šçº¿ç¨‹æœºåˆ¶

### 5.1 EventLoopçš„One Loop Per Threadæ¨¡å‹

**ä»£ç ä½ç½®**: `server/application/chat-room/muduo/net/EventLoop.h:14, 39`

```cpp
class EventLoop : noncopyable {
private:
    const pid_t threadId_;           // âœ… åˆ›å»ºEventLoopçš„çº¿ç¨‹ID
    std::atomic<bool> looping_;      // âœ… åŸå­æ ‡å¿—
    std::unique_ptr<Poller> poller_; // epollå°è£…

    // è·¨çº¿ç¨‹ä»»åŠ¡é˜Ÿåˆ—
    mutable MutexLock mutex_;
    std::vector<Functor> pendingFunctors_ GUARDED_BY(mutex_);

public:
    void loop() {
        assert(!looping_);
        assertInLoopThread();  // âœ… æ£€æŸ¥å¿…é¡»åœ¨åˆ›å»ºçº¿ç¨‹è°ƒç”¨
        looping_ = true;

        while (!quit_) {
            // 1. epoll_waitç­‰å¾…äº‹ä»¶
            activeChannels_.clear();
            pollReturnTime_ = poller_->poll(kPollTimeMs, &activeChannels_);

            // 2. å¤„ç†I/Oäº‹ä»¶
            for (Channel* channel : activeChannels_) {
                channel->handleEvent(pollReturnTime_);
            }

            // 3. å¤„ç†è·¨çº¿ç¨‹ä»»åŠ¡
            doPendingFunctors();
        }

        looping_ = false;
    }

    void runInLoop(Functor cb) {
        if (isInLoopThread()) {
            cb();  // åœ¨æœ¬çº¿ç¨‹ï¼Œç›´æ¥æ‰§è¡Œ
        } else {
            queueInLoop(std::move(cb));  // è·¨çº¿ç¨‹ï¼ŒåŠ å…¥é˜Ÿåˆ—
        }
    }

    void queueInLoop(Functor cb) {
        {
            MutexLockGuard lock(mutex_);
            pendingFunctors_.push_back(std::move(cb));
        }

        if (!isInLoopThread() || callingPendingFunctors_) {
            wakeup();  // âœ… é€šè¿‡eventfdå”¤é†’epoll
        }
    }
};
```

**è·¨çº¿ç¨‹é€šä¿¡åŸç†**:
```
çº¿ç¨‹A (EventLoopæ‰€åœ¨çº¿ç¨‹)       çº¿ç¨‹B (å…¶ä»–çº¿ç¨‹)
   â”‚                              â”‚
   â”œâ”€ loop()                      â”‚
   â”‚   â””â”€ epoll_wait() ğŸ”´é˜»å¡    â”‚
   â”‚                              â”œâ”€ runInLoop(callback)
   â”‚                              â”‚   â””â”€ queueInLoop(callback)
   â”‚                              â”‚       â”œâ”€ åŠ é”ï¼Œæ·»åŠ åˆ°pendingFunctors
   â”‚                              â”‚       â””â”€ wakeup()  âš¡
   â”‚                              â”‚           â””â”€ write(eventfd, 1)
   â”‚                              â”‚
   â”œâ”€ epoll_wait() ğŸŸ¢ è¿”å›        â”‚
   â”‚   â””â”€ æ£€æµ‹åˆ°eventfdå¯è¯»       â”‚
   â”œâ”€ doPendingFunctors()         â”‚
   â”‚   â””â”€ æ‰§è¡Œcallback            â”‚
   â””â”€ ç»§ç»­epoll_wait()            â”‚
```

---

### 5.2 EventLoopThreadPoolçš„è´Ÿè½½å‡è¡¡

**ä»£ç ä½ç½®**: `server/application/chat-room/muduo/net/EventLoopThreadPool.h:30-64`

```cpp
class EventLoopThreadPool : noncopyable {
private:
    EventLoop* baseLoop_;                                // ä¸»çº¿ç¨‹EventLoop
    std::vector<std::unique_ptr<EventLoopThread>> threads_;
    std::vector<EventLoop*> loops_;                      // å­çº¿ç¨‹EventLoopåˆ—è¡¨
    int next_;                                           // Round-Robinç´¢å¼•

public:
    void start(const ThreadInitCallback& cb) {
        for (int i = 0; i < numThreads_; ++i) {
            EventLoopThread* t = new EventLoopThread(cb, name_);
            threads_.push_back(std::unique_ptr<EventLoopThread>(t));
            loops_.push_back(t->startLoop());  // âœ… å¯åŠ¨å­çº¿ç¨‹EventLoop
        }
    }

    EventLoop* getNextLoop() {
        EventLoop* loop = baseLoop_;

        if (!loops_.empty()) {
            // âœ… Round-Robinè½®è¯¢
            loop = loops_[next_];
            ++next_;
            if (next_ >= loops_.size()) {
                next_ = 0;
            }
        }

        return loop;
    }

    EventLoop* getLoopForHash(size_t hashCode) {
        EventLoop* loop = baseLoop_;

        if (!loops_.empty()) {
            // âœ… å“ˆå¸Œåˆ†é…ï¼ˆåŒä¸€ç”¨æˆ·æ€»æ˜¯åˆ†é…åˆ°åŒä¸€EventLoopï¼‰
            loop = loops_[hashCode % loops_.size()];
        }

        return loop;
    }
};
```

**ä¸¤ç§è´Ÿè½½å‡è¡¡ç­–ç•¥**:

| ç­–ç•¥ | ä½¿ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|------|------|
| **Round-Robin** | é€šç”¨åœºæ™¯ | è´Ÿè½½å‡è¡¡å‡åŒ€ | æ— äº²å’Œæ€§ |
| **Hash** | åŒä¸€ç”¨æˆ·çš„å¤šä¸ªè¿æ¥ | å‡å°‘é”ç«äº‰ï¼Œç¼“å­˜å‹å¥½ | å¯èƒ½è´Ÿè½½ä¸å‡ |

---

### 5.3 ThreadPoolçš„ä»»åŠ¡é˜Ÿåˆ—åŒæ­¥

**ä»£ç ä½ç½®**: `server/application/chat-room/muduo/base/ThreadPool.h:20-67`

```cpp
class ThreadPool : noncopyable {
private:
    mutable MutexLock mutex_;
    Condition notEmpty_ GUARDED_BY(mutex_);  // âœ… ä»»åŠ¡é˜Ÿåˆ—éç©ºæ¡ä»¶
    Condition notFull_ GUARDED_BY(mutex_);   // âœ… ä»»åŠ¡é˜Ÿåˆ—æœªæ»¡æ¡ä»¶
    std::deque<Task> queue_ GUARDED_BY(mutex_);
    size_t maxQueueSize_;
    bool running_;
    std::vector<std::unique_ptr<muduo::Thread>> threads_;

public:
    void run(Task task) {
        if (threads_.empty()) {
            task();  // æ— çº¿ç¨‹æ± ï¼Œç›´æ¥æ‰§è¡Œ
        } else {
            MutexLockGuard lock(mutex_);

            // é˜Ÿåˆ—æ»¡æ—¶ç­‰å¾…
            while (isFull() && running_) {
                notFull_.wait();  // âœ… é˜»å¡ï¼Œç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºä½
            }

            if (!running_) return;

            queue_.push_back(std::move(task));
            notEmpty_.notify();  // âœ… å”¤é†’å·¥ä½œçº¿ç¨‹
        }
    }

private:
    void runInThread() {
        while (running_) {
            Task task = take();  // é˜»å¡è·å–ä»»åŠ¡
            if (task) {
                task();  // æ‰§è¡Œä»»åŠ¡
            }
        }
    }

    Task take() {
        MutexLockGuard lock(mutex_);

        // é˜Ÿåˆ—ç©ºæ—¶ç­‰å¾…
        while (queue_.empty() && running_) {
            notEmpty_.wait();  // âœ… é˜»å¡ï¼Œç­‰å¾…æ–°ä»»åŠ¡
        }

        Task task;
        if (!queue_.empty()) {
            task = queue_.front();
            queue_.pop_front();

            if (maxQueueSize_ > 0) {
                notFull_.notify();  // âœ… å”¤é†’ç”Ÿäº§è€…
            }
        }
        return task;
    }
};
```

**æœ‰ç•Œé˜Ÿåˆ—çš„æ„ä¹‰**:
```
æ— ç•Œé˜Ÿåˆ—ï¼ˆmaxQueueSize = 0ï¼‰:
  âœ… ç”Ÿäº§è€…æ°¸ä¸é˜»å¡
  âŒ ä»»åŠ¡å †ç§¯å¯èƒ½å¯¼è‡´å†…å­˜æº¢å‡º

æœ‰ç•Œé˜Ÿåˆ—ï¼ˆmaxQueueSize > 0ï¼‰:
  âœ… é™åˆ¶å†…å­˜å ç”¨
  âœ… èƒŒå‹æœºåˆ¶ï¼šç”Ÿäº§è¿‡å¿«æ—¶é˜»å¡ç”Ÿäº§è€…
  âŒ ç”Ÿäº§è€…å¯èƒ½é˜»å¡
```

## å…­ã€C++11å¤šçº¿ç¨‹æŠ€æœ¯æ€»è§ˆ

### 6.1 æ ¸å¿ƒåŒæ­¥åŸè¯­å¯¹æ¯”

| åŒæ­¥æœºåˆ¶ | å¤´æ–‡ä»¶ | é€‚ç”¨åœºæ™¯ | æ€§èƒ½ | é¡¹ç›®ä½¿ç”¨ä½ç½® |
|---------|--------|---------|------|------------|
| **std::mutex** | `<mutex>` | ç®€å•äº’æ–¥è®¿é—® | ä¸­ | PubSubService, è¿æ¥æ±  |
| **std::shared_mutex** (C++17) | `<shared_mutex>` | è¯»å¤šå†™å°‘ | é«˜ | ConnectionManager |
| **std::lock_guard** | `<mutex>` | RAIIè‡ªåŠ¨é”ç®¡ç† | - | æ‰€æœ‰ä¸´ç•ŒåŒº |
| **std::unique_lock** | `<mutex>` | éœ€è¦æ‰‹åŠ¨è§£é”/æ¡ä»¶å˜é‡ | ä¸­ | è¿æ¥æ±  |
| **std::condition_variable** | `<condition_variable>` | çº¿ç¨‹é—´åŒæ­¥/ç­‰å¾…é€šçŸ¥ | é«˜ | è¿æ¥æ± , çº¿ç¨‹æ±  |
| **std::atomic** | `<atomic>` | æ— é”åŸå­æ“ä½œ | æœ€é«˜ | ConnectionManager |
| **std::thread** | `<thread>` | åˆ›å»ºçº¿ç¨‹ | - | gRPCæœåŠ¡çº¿ç¨‹ |

### 6.2 é¡¹ç›®ä¸­çš„åŒæ­¥æ¨¡å¼

#### æ¨¡å¼1: è¯»å†™é”ï¼ˆRead-Write Lockï¼‰

```cpp
// è¯»è€…ï¼ˆå¤šä¸ªå¯å¹¶å‘ï¼‰
std::shared_lock<std::shared_mutex> lock(m_mutex);
auto it = m_connections.find(id);

// å†™è€…ï¼ˆç‹¬å ï¼‰
std::unique_lock<std::shared_mutex> lock(m_mutex);
m_connections[id] = handler;
```

#### æ¨¡å¼2: ç”Ÿäº§è€…-æ¶ˆè´¹è€…ï¼ˆProducer-Consumerï¼‰

```cpp
// ç”Ÿäº§è€…
{
    std::unique_lock<std::mutex> lock(mutex_);
    while (queue_.full()) {
        notFull_.wait(lock);  // ç­‰å¾…æ¶ˆè´¹
    }
    queue_.push(item);
    notEmpty_.notify();  // é€šçŸ¥æ¶ˆè´¹è€…
}

// æ¶ˆè´¹è€…
{
    std::unique_lock<std::mutex> lock(mutex_);
    while (queue_.empty()) {
        notEmpty_.wait(lock);  // ç­‰å¾…ç”Ÿäº§
    }
    item = queue_.pop();
    notFull_.notify();  // é€šçŸ¥ç”Ÿäº§è€…
}
```

#### æ¨¡å¼3: RAIIèµ„æºç®¡ç†

```cpp
class AutoRelease {
public:
    AutoRelease(Resource* res) : res_(res) {}
    ~AutoRelease() { release(res_); }  // âœ… è‡ªåŠ¨é‡Šæ”¾
private:
    Resource* res_;
};

// ä½¿ç”¨
{
    Resource* res = acquire();
    AutoRelease guard(res);
    // ... ä½¿ç”¨èµ„æº
}  // âœ… è‡ªåŠ¨é‡Šæ”¾ï¼Œå³ä½¿æŠ›å¼‚å¸¸
```

## ä¸ƒã€é¢è¯•è¦ç‚¹é€ŸæŸ¥

### 7.1 å¤šçº¿ç¨‹åŸºç¡€

**Q: ä¸ºä»€ä¹ˆéœ€è¦å¤šçº¿ç¨‹ï¼Ÿ**

- å……åˆ†åˆ©ç”¨å¤šæ ¸CPU
- I/Oä¸è®¡ç®—å¹¶è¡Œ
- æé«˜å“åº”é€Ÿåº¦å’Œååé‡

**Q: çº¿ç¨‹å®‰å…¨çš„å®šä¹‰ï¼Ÿ**
å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«æ•°æ®æ—¶ï¼Œç¨‹åºè¡Œä¸ºç¬¦åˆé¢„æœŸï¼Œä¸ä¼šå‡ºç°æ•°æ®ç«äº‰ã€æ­»é”ç­‰é—®é¢˜ã€‚

**Q: å¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Ÿ**
1. äº’æ–¥é”ï¼ˆmutexï¼‰ä¿æŠ¤ä¸´ç•ŒåŒº
2. åŸå­æ“ä½œï¼ˆatomicï¼‰
3. æ— é”æ•°æ®ç»“æ„
4. çº¿ç¨‹å±€éƒ¨å­˜å‚¨ï¼ˆthread_localï¼‰

### 7.2 é¡¹ç›®å®æˆ˜é—®é¢˜

**Q: ä½ çš„é¡¹ç›®ä¸­å“ªé‡Œç”¨åˆ°äº†å¤šçº¿ç¨‹ï¼Ÿ**

ç­”æ¡ˆæ¡†æ¶ï¼š
1. **Muduo Reactorå¤šçº¿ç¨‹**ï¼šä¸»çº¿ç¨‹Acceptï¼Œå­çº¿ç¨‹å¤„ç†è¿æ¥ï¼ˆOne Loop Per Threadï¼‰
2. **ä¸šåŠ¡çº¿ç¨‹æ± **ï¼šåˆ†ç¦»I/Oå’Œè®¡ç®—ï¼Œé¿å…é˜»å¡EventLoop
3. **gRPCç‹¬ç«‹çº¿ç¨‹**ï¼šä¸HTTPæœåŠ¡å¹¶è¡Œè¿è¡Œ
4. **è¿æ¥æ± **ï¼šä½¿ç”¨æ¡ä»¶å˜é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

**Q: å¦‚ä½•è§£å†³æ•°æ®ç«äº‰ï¼Ÿ**

é¡¹ç›®æ¡ˆä¾‹ï¼š
```cpp
// âŒ æ•°æ®ç«äº‰
std::unordered_map<string, Connection*> connections;

void Thread1() { connections["user1"] = conn1; }  // å†™
void Thread2() { auto c = connections["user2"]; } // è¯»

// âœ… è§£å†³æ–¹æ¡ˆ1: äº’æ–¥é”
std::mutex mtx;
void Thread1() {
    std::lock_guard<std::mutex> lock(mtx);
    connections["user1"] = conn1;
}

// âœ… è§£å†³æ–¹æ¡ˆ2: è¯»å†™é”
std::shared_mutex mtx;
void Thread1() {
    std::unique_lock<std::shared_mutex> lock(mtx);  // å†™é”
    connections["user1"] = conn1;
}
void Thread2() {
    std::shared_lock<std::shared_mutex> lock(mtx);  // è¯»é”
    auto c = connections["user2"];
}
```

### 7.3 æ€§èƒ½ä¼˜åŒ–

**Q: å¦‚ä½•å‡å°‘é”ç«äº‰ï¼Ÿ**

1. **ç¼©å°é”ç²’åº¦**ï¼šåªä¿æŠ¤å¿…è¦çš„ä»£ç 
   
   ```cpp
   // âŒ é”ç²’åº¦è¿‡å¤§
   {
       std::lock_guard<std::mutex> lock(mtx);
       auto data = getData();  // å¯èƒ½è€—æ—¶
       processData(data);      // å¯èƒ½è€—æ—¶
       saveData(data);         // éœ€è¦ä¿æŠ¤
   }
   
   // âœ… åªé”å¿…è¦éƒ¨åˆ†
   auto data = getData();
   processData(data);
   {
       std::lock_guard<std::mutex> lock(mtx);
       saveData(data);
   }
   ```
   
2. **ä½¿ç”¨è¯»å†™é”**ï¼šè¯»æ“ä½œå¹¶å‘
3. **æ— é”ç¼–ç¨‹**ï¼š`std::atomic`
4. **åˆ†æ®µé”**ï¼šConcurrentHashMapçš„æ€æƒ³

**Q: æ¡ä»¶å˜é‡ç›¸æ¯”è½®è¯¢æœ‰ä»€ä¹ˆä¼˜åŠ¿ï¼Ÿ**

| æ–¹å¼ | CPUå ç”¨ | å“åº”å»¶è¿Ÿ |
|------|---------|---------|
| å¿™ç­‰ï¼ˆwhileå¾ªç¯ï¼‰ | 100% | 0 |
| ç¡çœ è½®è¯¢ï¼ˆsleepï¼‰ | ä½ | ç¡çœ æ—¶é—´ |
| æ¡ä»¶å˜é‡ | 0% | 0 |

### 7.4 å¸¸è§é™·é˜±

**é™·é˜±1: æ­»é”**
```cpp
// âŒ æ­»é”ç¤ºä¾‹
void Thread1() {
    lock(mutex1);
    lock(mutex2);  // ğŸ”´
}
void Thread2() {
    lock(mutex2);
    lock(mutex1);  // ğŸ”´ å¯èƒ½æ­»é”
}

// âœ… è§£å†³æ–¹æ¡ˆï¼šå›ºå®šåŠ é”é¡ºåº
void Thread1() { lock(mutex1); lock(mutex2); }
void Thread2() { lock(mutex1); lock(mutex2); }
```

**é™·é˜±2: è™šå‡å”¤é†’ï¼ˆSpurious Wakeupï¼‰**
```cpp
// âŒ é”™è¯¯
if (queue.empty()) {
    cond.wait(lock);  // å¯èƒ½è™šå‡å”¤é†’
}
auto item = queue.pop();

// âœ… æ­£ç¡®ï¼šä½¿ç”¨whileå¾ªç¯
while (queue.empty()) {
    cond.wait(lock);
}
auto item = queue.pop();
```

**é™·é˜±3: å¿˜è®°è§£é”**
```cpp
// âŒ å¼‚å¸¸å¯¼è‡´æœªè§£é”
mutex.lock();
throw std::exception();  // ğŸ”´ é”æ°¸ä¹…æŒæœ‰
mutex.unlock();

// âœ… RAIIè‡ªåŠ¨ç®¡ç†
std::lock_guard<std::mutex> lock(mutex);
throw std::exception();  // âœ… è‡ªåŠ¨è§£é”
```

## å…«ã€æ€»ç»“ï¼šé¡¹ç›®å¤šçº¿ç¨‹æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Comet Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¸»çº¿ç¨‹EventLoop (Acceptæ–°è¿æ¥)                          â”‚
â”‚     â”‚                                                    â”‚
â”‚     â”œâ”€ å­çº¿ç¨‹1: EventLoop1 (å¤„ç†è¿æ¥1, 3, 5...)         â”‚
â”‚     â”œâ”€ å­çº¿ç¨‹2: EventLoop2 (å¤„ç†è¿æ¥2, 4, 6...)         â”‚
â”‚     â””â”€ å­çº¿ç¨‹3: EventLoop3 (å¤„ç†è¿æ¥...)                 â”‚
â”‚                                                           â”‚
â”‚  ä¸šåŠ¡çº¿ç¨‹æ±  (4ä¸ªWorker)                                  â”‚
â”‚     â”œâ”€ Worker1: è§£æWebSocketæ¶ˆæ¯                        â”‚
â”‚     â”œâ”€ Worker2: å¤„ç†ä¸šåŠ¡é€»è¾‘                             â”‚
â”‚     â””â”€ Worker3/4: JSONåºåˆ—åŒ–                             â”‚
â”‚                                                           â”‚
â”‚  gRPCçº¿ç¨‹ (æ¥æ”¶Jobæ¨é€)                                  â”‚
â”‚     â””â”€ å¹¿æ’­æ¶ˆæ¯åˆ°æ‰€æœ‰WebSocketè¿æ¥                       â”‚
â”‚                                                           â”‚
â”‚  åŒæ­¥æœºåˆ¶:                                               â”‚
â”‚     â”œâ”€ ConnectionManager:shared_mutex (è¯»å†™é”)         â”‚
â”‚     â”œâ”€ PubSubService:mutex (æˆ¿é—´è®¢é˜…)                  â”‚
â”‚     â””â”€ s_user_ws_conn_map:mutex (è¿æ¥æ˜ å°„)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Job Layer                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¸»çº¿ç¨‹EventLoop (ç©ºé—²ï¼Œå¯æ‰©å±•)                          â”‚
â”‚                                                           â”‚
â”‚  ThreadPool (4ä¸ªWorker)                                  â”‚
â”‚     â””â”€ Worker1: Kafkaæ¶ˆè´¹ â†’ Protobufè§£æ â†’ gRPCæ¨é€     â”‚
â”‚                                                           â”‚
â”‚  åŒæ­¥æœºåˆ¶:                                               â”‚
â”‚     â””â”€ å•ä¾‹getInstance: C++11å±€éƒ¨é™æ€å˜é‡çº¿ç¨‹å®‰å…¨        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Logic Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ä¸»çº¿ç¨‹EventLoop (Accept HTTPè¯·æ±‚)                       â”‚
â”‚     â”‚                                                    â”‚
â”‚     â”œâ”€ å­çº¿ç¨‹1: EventLoop1 (å¤„ç†HTTPè¿æ¥1, 3, 5...)     â”‚
â”‚     â”œâ”€ å­çº¿ç¨‹2: EventLoop2 (å¤„ç†HTTPè¿æ¥2, 4, 6...)     â”‚
â”‚     â””â”€ å­çº¿ç¨‹3: EventLoop3 (å¤„ç†HTTPè¿æ¥...)             â”‚
â”‚                                                           â”‚
â”‚  èµ„æºæ± :                                                 â”‚
â”‚     â”œâ”€ MySQLè¿æ¥æ±  (æœ€å¤§20ä¸ªè¿æ¥)                        â”‚
â”‚     â””â”€ Redisè¿æ¥æ±  (æœ€å¤§10ä¸ªè¿æ¥)                        â”‚
â”‚                                                           â”‚
â”‚  åŒæ­¥æœºåˆ¶:                                               â”‚
â”‚     â”œâ”€ CDBPool: mutex + condition_variable              â”‚
â”‚     â”œâ”€ CachePool: mutex + condition_variable            â”‚
â”‚     â””â”€ AutoRelease: RAIIè‡ªåŠ¨å½’è¿˜è¿æ¥                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```





é¢è¯•å®˜æ‚¨å¥½ï¼Œæˆ‘å«ä½•æ¸…ï¼Œæ˜¯26å±Šæ·±åœ³å¤§å­¦è®¡ç®—æœºä¸è½¯ä»¶å­¦é™¢çš„ç¡•å£«ç”Ÿï¼Œæ„Ÿè°¢è´µå…¬å¸ç»™æˆ‘ä¸€æ¬¡é¢è¯•æœºä¼šï¼Œæˆ‘å°†ä»æŠ€æœ¯æ ˆã€é¡¹ç›®ç»å†å’Œå®ä¹ ç»å†ä¸‰ä¸ªæ–¹é¢ä»‹ç»ä¸€ä¸‹æˆ‘è‡ªå·±ã€‚

é¦–å…ˆï¼Œæˆ‘ç›®å‰çš„æŠ€æœ¯æ ˆä¸»è¦æ˜¯åå‘äºc++æœåŠ¡å™¨åç«¯å¼€å‘è¿™ä¸€å—ï¼Œæ¯”å¦‚åŸºäº Linuxçš„ç³»ç»Ÿç¼–ç¨‹ã€ç½‘ç»œç¼–ç¨‹ç­‰ï¼Œä»¥åŠå…·å¤‡åŸºäºC++11å¤šçº¿ç¨‹åŒæ­¥ï¼ˆäº’æ–¥é”/æ¡ä»¶å˜é‡ï¼‰å¼€å‘çš„èƒ½åŠ›ï¼Œæ­¤å¤–ï¼Œä¹Ÿèƒ½åŸºäº QT5è¿›è¡Œå·¥ä¸šè½¯ä»¶ç­‰çš„å®¢æˆ·ç«¯å¼€å‘ï¼Œç„¶åæˆ‘æœ¬ç§‘ä¹Ÿæ˜¯å­¦è®¡ç®—æœºçš„å˜›ï¼Œå¯¹æ•°æ®ç»“æ„ã€æ“ä½œç³»ç»Ÿå’Œè®¡ç®—æœºç½‘ç»œç­‰ä¸“ä¸šçŸ¥è¯†æœ‰ä¸€å®šçš„åŸºç¡€ã€‚

é¡¹ç›®ç»å†æ–¹é¢ï¼š

æˆ‘åšçš„ç¬¬ä¸€ä¸ªé¡¹ç›®æ˜¯è½»é‡çº§çš„linuxå¤šçº¿ç¨‹webæœåŠ¡å™¨ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯ä»¥è§£æHTTPè¯·æ±‚ï¼Œç»„ç»‡HTTPå“åº”çš„é«˜æ€§èƒ½webæœåŠ¡å™¨ï¼Œé€šè¿‡æ€§èƒ½æµ‹è¯•å·¥å…·æµ‹è¯•å…¶æ€§èƒ½å¯è¾¾1w+çš„QPSï¼Œè¿™ä¸ªé¡¹ç›®ä¸»è¦é€šè¿‡ posix çº¿ç¨‹åº“å°è£…çº¿ç¨‹æ± ã€å®šæ—¶å™¨ï¼Œä»¥åŠä½¿ç”¨IOå¤šè·¯å¤ç”¨ç­‰ç›¸å…³çš„æŠ€æœ¯æ ˆæ¥å®ç°ã€‚

æ­¤å¤–ï¼Œå¦ä¸€ä¸ªæ ¸å¿ƒé¡¹ç›®æ˜¯åˆ†å¸ƒå¼å®æ—¶æ¶ˆæ¯æ¨é€ç³»ç»Ÿï¼Œè¿™ä¸ªé¡¹ç›®ä¹Ÿæ˜¯åœ¨æˆ‘å®ä¹ å®Œä¹‹åï¼Œå—åˆ°å¯å‘ä¼˜åŒ–åçš„ä¸€ä¸ªé¡¹ç›®ï¼Œå®ƒæœ€å¼€å§‹æ˜¯ä¸€ä¸ªå•æœºç‰ˆçš„ï¼Œä¼˜åŒ–ä¹‹åï¼Œé€šè¿‡åˆ†å±‚è§£è€¦æ¶æ„ï¼Œå¹¶ä¸”åŠ å…¥äº†æ¶ˆæ¯é˜Ÿåˆ—ä¸­é—´ä»¶ï¼Œå®ç°äº†æ¶ˆæ¯çš„å¼‚æ­¥å‘é€ã€æµé‡å‰Šå³°å’Œä¸šåŠ¡é€»è¾‘è§£è€¦ï¼Œä¸»è¦ä½¿ç”¨çš„æŠ€æœ¯æ ˆæœ‰Muduoç½‘ç»œåº“ã€gRPCã€Kafkaå’ŒRedisç­‰ï¼Œé¡¹ç›®åˆ†å±‚è§£è€¦åï¼Œä¹Ÿåˆ¶ä½œæˆäº†dockeré•œåƒï¼Œå¹¶ä¸”é€šè¿‡docker-composeéƒ¨ç½²åˆ°äº†äº‘æœåŠ¡å™¨ä¸Šã€‚

åœ¨å®ä¹ ç»å†æ–¹é¢ï¼Œæˆ‘æœ‰ä¸€æ®µä½¿ç”¨Goè¿›è¡Œå¾®æœåŠ¡å¼€å‘çš„å®ä¹ ç»å†ï¼Œåœ¨å®ä¹ çš„ä¸¤ä¸ªæœˆæœŸé—´ï¼Œæˆ‘é€šè¿‡å­¦ä¹ goè¯­è¨€æœ¬èº«åŠå…¶åœ¨é«˜å¹¶å‘ä¸Šçš„åº”ç”¨ï¼Œå‚ä¸äº†å…¬å¸äº‘äº§å“ç®¡ç†ç³»ç»Ÿçš„APIç®¡ç†æ¨¡å—ã€APIåˆ†ç»„æ¨¡å—ï¼Œæœ€åï¼ŒåŸºäºconsulå®ç°æœåŠ¡æ³¨å†Œå’Œå‘ç°ï¼Œå¹¶ä¸”å®ç°å°†ç½‘å…³å±‚çš„HTTPè¯·æ±‚è½¬å‘åˆ°å¯¹åº”å¾®æœåŠ¡çš„å·¥ä½œï¼Œè¿™æ®µå®ä¹ æå‡äº†æˆ‘å¯¹åç«¯é¡¹ç›®å¼€å‘çš„ä¸šåŠ¡å’Œåˆ†å¸ƒå¼çš„ç†è§£ã€‚
