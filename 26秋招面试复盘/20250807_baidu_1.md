# 百度 C++ 研发一面复盘

## 自我介绍

这里面试官非常好，他先对岗位进行了解释，然后才让我做一个简单的自我介绍 ==> 套用常规暑期实习模板。

## 问题

这次百度一面比较新颖，上来不是问问题，而是让写一段 c++ 类继承的代码，然后基于此来问。

```c++
#include<iostream>
using namespace std;

class Animal {
public:
    string name;
    Animal() {
        // 需要实现默认构造函数
    }

    Animal(const string& name) {
        this->name = name;
        cout << "A" << endl;
    }

    virtual void speak() {
        cout << this->name << " animal speak" << endl;
    }

    virtual ~Animal() {
        cout << "~A" << endl;
    }
};

class Dog : public Animal {
public:
    Dog() {

    }

    Dog(const string name) :Animal(name) {
        cout << "D" << endl;
    }

    virtual void speak() {
        cout << this->name << " dog speak" << endl;
    }

    virtual ~Dog() {
        cout << "~D" << endl;
    }
};

int main() {
    Animal* d1 = new Dog("Tom");
    Animal* d2 = nullptr;
  	
  	d1->speak();
		d2->speak();
  	
    delete d1;
    system("pause");
    return 0;
}
```

**问题1：**构造函数的调用顺序？

很基础，直接回答先执行父类的构造函数，再执行子类的构造函数。需要注意的是，虚基类的析构函数记得也需要声明为虚函数。



**问题2：**上述代码中，d2 赋值为 `nullptr`，调用 `speak()` 会失败吗？

这里我回答的比较直接，肯定会报错的，因为 d2 是空指针，没有指向具体的一块堆区内存，演示代码的时候报错为 `segmentation fault` 错误。



**问题3：**基于问题2的深入，你知道这个 `segmentation fault` 错误是什么意思吗，一般什么情况下会出现这个错误？



```c++
#include<iostream>
using namespace std;

class Animal {
public:
    string name;
    Animal() {
        // 需要实现默认构造函数
    }

    Animal(const string& name) {
        this->name = name;
        cout << "A" << endl;
    }

    void speak() {
        cout << this->name << " animal speak" << endl;
    }

    void speak1() {
        cout << "animal speak1" << endl;
    }

    ~Animal() {
        cout << "~A" << endl;
    }
};

class Dog : public Animal {
public:
    Dog() {

    }

    Dog(const string name) :Animal(name) {
        cout << "D" << endl;
    }

    void speak() {
        cout << this->name << " dog speak" << endl;
    }

    void speak1() {
        cout << "dog speak1" << endl;
    }

    ~Dog() {
        cout << "~D" << endl;
    }
};

int main() {
    Animal* d1 = new Dog("Tom");
    Dog* d2 = nullptr;

    d1->speak();

    d2->speak1();

    delete d1;

    system("pause");
    return 0;
}
```

**问题4：**这里没有多态的实现，为什么 d2 是空指针，但是 `d2->speak()` 不会报错？（震碎了我的编程观，可以说我的 c++ 基础非常不好吧）

这个问题应该是基于问题2的一个拓展，因为在问题2中，我回答的比较肯定，空指针访问堆区内存，一定会造成内存访问错误。



**问题5：**谈谈什么是野指针，悬空指针，这两者的区别和危害是什么？



**问题6：**刚刚你说到了内存泄漏，说一下你对内存泄漏的理解？



**问题7：**你对 `this` 指针了解多少，如果让你用 C 语言实现 this 指针的功能，比如同一个类下，不同的对象能够通过这个 `this` 指针访问自己的成员函数，而不造成歧义？



**问题8：** 在继承中，两个子类对象，在内存当中，其父类的副本只会有一个吗，还是会有两个？



从下面的问题开始，面试官从 c++ 内存的深入脱离出来了，开始问一些基础性的知识。



**问题8：**`public`，`protected`，`private` 三个继承方式的区别？
这么基础的问题，我居然没答的很完美，只能说准备的不充分吧，有点忘记了，应该从继承的角度来考虑，不同的继承方式会改变父类成员变量和成员函数的权限。



**问题9：**说一下 `vector` 和 `list`、`map` 和 `unordered_map` 的区别吧？



**问题10：**谈谈 `push_back()` 和 `emplace_back()` 的区别，顺便说一下两者的使用场景？



**问题11：**刚刚说到了 `push_back()` 在插入 `int` 等基本数据类型的时候，效率会更高，是为什么呢？

这里相当于给自己挖了一个坑，直接说不清楚了，这里 `push_back()` 肯定是有它存在的道理的，需要弄清楚什么时候使用 `push_back()`，什么时候使用 `emplace_back()`。



**问题12：**聊一聊 c++11 的智能指针？



**问题13：**你用的最多的智能指针是哪一个，`unique_ptr<T> ` 和 `shared_ptr<T>` 你会分别在什么情况下使用？



**问题14：**关于 c++11 的线程同步问题，说一下你使用最多的线程同步方式？



**问题15：**`atomic` 有使用过吗，它的作用是什么？



**问题16：**综合问题 14 和 15，谈谈你对条件变量的理解，对比 `atomic`，使用互斥锁和条件变量的优势是什么，亦或者是说，两者的使用场景是什么？

这个问题我只能尝试性的回答，因为 `atomic` 使用的非常少。



**问题17：**多进程有使用过吗？



**问题18：**知道哪些设计模式？





## 手撕题目

求两个 int 类型整数的平均值，不能借用取值更大的类型来进行相加。

> 问题本质：两个符号相同的数相加，会出现溢出，分两种情况：
>
> - 符号不同，直接相加除2就可以了（此时一定不会溢出）；
>
> - 符号相同，两个数相减，得到差值，较小的数加上差值的一半，即得到平均数。