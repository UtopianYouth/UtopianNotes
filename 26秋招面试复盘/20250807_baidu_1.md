# 百度 C++ 研发一面复盘

## 自我介绍

这里面试官非常好，他先对岗位进行了解释，然后才让我做一个简单的自我介绍 ==> 套用常规暑期实习模板。

## 问题

这次百度一面比较新颖，上来不是问问题，而是让写一段 c++ 类继承的代码，然后基于此来问。

```c++
#include<iostream>
using namespace std;

class Animal {
public:
    string name;
    Animal() {
        // 需要实现默认构造函数
    }

    Animal(const string& name) {
        this->name = name;
        cout << "A" << endl;
    }

    virtual void speak() {
        cout << this->name << " animal speak" << endl;
    }

    virtual ~Animal() {
        cout << "~A" << endl;
    }
};

class Dog : public Animal {
public:
    Dog() {

    }

    Dog(const string name) :Animal(name) {
        cout << "D" << endl;
    }

    virtual void speak() {
        cout << this->name << " dog speak" << endl;
    }

    virtual ~Dog() {
        cout << "~D" << endl;
    }
};

int main() {
    Animal* d1 = new Dog("Tom");
    Animal* d2 = nullptr;
  	
  	d1->speak();
    d2->speak();
  	
    delete d1;
    system("pause");
    return 0;
}
```

**问题1：**构造函数的调用顺序？

很基础，直接回答先执行父类的构造函数，再执行子类的构造函数。需要注意的是，虚基类的析构函数记得也需要声明为虚函数。



**问题2：**上述代码中，`d2` 赋值为 `nullptr`，调用 `speak()` 会失败吗？

这里我回答的比较直接，肯定会报错的，因为 `d2` 是空指针，没有指向具体的一块堆区内存，演示代码的时候报错为 `segmentation fault` 错误。

> **深入回答**
>
> - 空指针解引用属于未定义行为；
>
> - `speak()` 属于虚函数，虚函数的调用需要**通过对象的虚表（`vtable`）查找函数地址**，`this` 指针为 `nullptr` 时，访问 `vtable` 会触发非法内存访问；
> - 即使虚函数调用本身可能不立即崩溃，`speak()`函数内部访问 `this->name`（等价于 `nullptr->name`）必然导致**解引用空指针**。



**问题3：**基于问题2的深入，你知道这个 `segmentation fault` 错误是什么意思吗，一般什么情况下会出现这个错误？

这里回答的比较浅，就说了非法访问不应该访问的内存时，会报段错误，比如数组越界访问。

> **深入回答**
>
> **段错误（Segmentation Fault）** 是操作系统对非法内存访问时，触发的保护机制。
>
> 程序运行时，OS 为其分配内存包括代码段、数据段、和堆栈段等，不同的内存段有不同的访问权限（可读 or 可写 or 可执行），当我们访问未分配 or 无权限 or 不存在的内存区域时，会触发。
>
> ```c++
> // 触发 segmentation fault 的常见场景如下
> 
> // 1. 空指针解引用（最常见）
> int* ptr = nullptr;
> *ptr = 10;
> 
> // 2. 访问已释放内存
> int* arr = new int[10];
> delete[] arr;
> arr[0] = 5;
> 
> // 3. 数组越界访问
> int arr[5];
> arr[10] = 100;
> 
> // 4. 栈溢出（递归时经常出现）
> void infinite_recursion() {
>     infinite_recursion();
> }
> 
> // 5. 无权限访问非法地址
> int* ptr = (int*)0xDEADBEEF;
> *ptr = 123;           
> 
> // 6. 修改只读内存
> char* str = "constant";  // 字符串常量在只读段
> str[0] = 'C';
> ```
>
> 段错误宏观流程：CPU的内存管理单元（`MMU`）检测到非法访问 ==> 内核发送 `SIGSEGV` 信号 ==> 进程被强制终止，生成核心转储（core dump）。
>
> 什么是核心转储（core dump）？
>
> 操作系统在程序崩溃时生成的进程内存快照文件，记录了程序崩溃瞬间的完整状态：
>
> - 进程内存镜像（代码段、数据段、堆栈）；
> - CPU寄存器状态（包括程序计数器）；
> - 打开的文件描述符；
> - 线程状态等。
>
> 可以通过核心转储分析段错误产生的根本原因。



```c++
#include<iostream>
using namespace std;

class Animal {
public:
    string name;
    Animal() {
        // 需要实现默认构造函数
    }

    Animal(const string& name) {
        this->name = name;
        cout << "A" << endl;
    }

    void speak() {
        cout << this->name << " animal speak" << endl;
    }

    void speak1() {
        cout << "animal speak1" << endl;
    }

    ~Animal() {
        cout << "~A" << endl;
    }
};

class Dog : public Animal {
public:
    Dog() {

    }

    Dog(const string name) :Animal(name) {
        cout << "D" << endl;
    }

    void speak() {
        cout << this->name << " dog speak" << endl;
    }

    void speak1() {
        cout << "dog speak1" << endl;
    }

    ~Dog() {
        cout << "~D" << endl;
    }
};

int main() {
    Animal* d1 = new Dog("Tom");
    Dog* d2 = nullptr;

    d1->speak();

    d2->speak1();

    delete d1;

    system("pause");
    return 0;
}
```

**问题4：**这里没有多态的实现，为什么 d2 是空指针，但是 `d2->speak1()` 不会报错？（震碎了我的编程观，可以说我的 c++ 基础非常不好吧）

这个问题应该是基于问题2的一个拓展，因为在问题2中，我回答的比较肯定，空指针访问堆区内存，一定会造成内存访问错误。

> 深入回答：从类和对象的模型角度思考
>
> 上述代码不会报错，核心是**非虚函数的静态绑定**，不需要 this 指针从虚函数表中获取函数执行的入口地址，所以不会产生段错误。
>
> <font color = red>静态绑定（早期绑定）</font>：是指在编译时确定函数调用的入口地址和具体实现，对于非虚函数，编译器在编译阶段就能确定调用哪个函数。
>
> 在内存中，类由两部分组成：
>
> - 实例数据：每个对象独有的成员变量（存储在堆栈段）；
> - 函数代码：所有对象共享函数的实现（存储在代码段）。
>
> ```c++
> /*
> +-------------------+      +----------------------+
> | Dog 对象实例      |      | 代码段               |
> +-------------------+      +----------------------+
> | name: string      |      | Dog::speak1() 代码   |
> | (成员数据)        |      | Animal::speak() 代码 |
> +-------------------+      | Dog::speak() 代码    |
>                            +----------------------+
> */
> ```
>
> **非虚函数的调用机制（没报错的核心原因）**
>
> `d2->speak1()` ==> `Dog::speak1(d2)` ==> `Dog::speak1(Dog* this)`
>
> <font color =red>注：</font>C++中，非静态成员函数都有一个隐式参数 `this` 指针，其值就是对象所在内存的地址，`this` 指针的存在，使得每一个对象在调用非静态成员函数的时候，都可以访问自己的成员变量（深入理解其本质就是，代码段中只有一份共享的成员函数，`this` 指针可以让编译器区分不同的对象调用共享成员函数）。
>
> 第一份代码是基于多态的，属于动态绑定，运行时获取函数的入口地址，需要通过 `this` 指针找到虚函数表，进而在表项中拿到虚成员函数的入口地址，而 `this` 指针是 `nullptr`，空指针解引用会触发 segmentation fault。



**问题5：**谈谈什么是野指针，悬空指针，这两者的区别和危害是什么？

> 野指针：定义了未初始化的指针，指向的内存地址不确定；
>
> 悬空指针：指向已经释放内存区域的指针，一般是内存释放后，指针没有置空造成的。
>
> 野指针和悬空指针都会造成内存破坏
>
> - 野指针会对未知的内存区域进行访问，如果向未知内存区域写入数据，会覆盖有效的旧数据；
> - 悬空指针由于指向的是已经释放的内存，如果该内存有新数据，悬空指针可能污染该数据。



**问题6：**刚刚你说到了内存泄漏，说一下你对内存泄漏的理解？

> 这里犯了一个非常基础性的错误，悬空指针和野指针不会造成内存泄漏，复习一下内存泄漏的概念。
>
> <font color = red>内存泄漏：</font>程序**动态分配的内存无法被回收**，导致该内存区域永远不可用，在 C++ 编程中，出现内存泄漏最多的情况就是手动分配内存，但是没有手动释放，建议使用智能指针管理堆区内存对象的生命周期。
>
> ```c++
> /*
> 	常见的四种内存泄漏
> */
> 
> // 1. 显示泄漏
> void memory_leak(){
>  int *p = new int(42);
>  // 没有 delete，造成内存泄漏
> }
> 
> // 2. 隐式泄漏（更隐蔽，面试重点）
> void implicit_leak() {
>     std::vector<int*> ptrs;
>     for (int i = 0; i < 100; ++i) {
>         ptrs.push_back(new int(i));
>     }
>     // 没有遍历释放 ==> 泄漏
> }
> 
> // 3. 异常路径泄漏
> void exception_leak() {
>     Resource* res = new Resource();
>     risky_operation(); // 可能抛出异常
>     delete res;        // 异常时跳过此句
> }
> 
> // 静态持有泄漏（系统设计层面）
> static std::map<int, Resource*> cache;
> void add_to_cache(int id) {
>     // 永久持有，没有释放
>     cache[id] = new Resource();
> }
> ```
>
> **拓展**
>
> ```C++
> /*
> 	大厂常见的泄漏场景
> */
> 
> // 1. 服务端程序长期运行泄漏 ==> HTTP 服务器未及时关闭 TCP 连接
> 
> // 2. 容器类泄漏
> void container_leak() {
>     std::vector<Object*> objects;
>     objects.push_back(new Object());
>     objects.clear(); // 没有 delete
> }
> 
> // 3. 回调注册泄漏
> class EventSystem {
>     static std::vector<Handler*> handlers;
> public:
>     void register_handler(Handler* h) {
>         handlers.push_back(h);
>     }
>     // 没有unregister机制 ==> 泄漏
> };
> 
> // 4. 智能指针循环引用泄漏
> struct Node {
>     std::shared_ptr<Node> next;
> };
> 
> auto node1 = std::make_shared<Node>();
> auto node2 = std::make_shared<Node>();
> node1->next = node2;
> node2->next = node1; 
> // 引用计数不为0 ==> 泄漏
> ```
>
> 预防内存泄漏
>
> - 编码层：`RAII`+智能指针
> - 构建层：编译选项 `-fsanitize=address`
> - 测试层：`Valgrind` 压力测试
> - 监控层：`tcmalloc` 实时采样



**问题7：**你对 `this` 指针了解多少，如果让你用 C 语言实现 this 指针的功能，比如同一个类下，不同的对象能够通过这个 `this` 指针访问自己的成员函数，而不造成歧义？



**问题8：** 在继承中，两个子类对象，在内存当中，其父类的副本只会有一个吗，还是会有两个？



从下面的问题开始，面试官从 c++ 内存的深入脱离出来了，开始问一些基础性的知识。



**问题8：**`public`，`protected`，`private` 三个继承方式的区别？
这么基础的问题，我居然没答的很完美，只能说准备的不充分吧，有点忘记了，应该从继承的角度来考虑，不同的继承方式会改变父类成员变量和成员函数的权限。



**问题9：**说一下 `vector` 和 `list`、`map` 和 `unordered_map` 的区别吧？



**问题10：**谈谈 `push_back()` 和 `emplace_back()` 的区别，顺便说一下两者的使用场景？



**问题11：**刚刚说到了 `push_back()` 在插入 `int` 等基本数据类型的时候，效率会更高，是为什么呢？

这里相当于给自己挖了一个坑，直接说不清楚了，这里 `push_back()` 肯定是有它存在的道理的，需要弄清楚什么时候使用 `push_back()`，什么时候使用 `emplace_back()`。



**问题12：**聊一聊 c++11 的智能指针？



**问题13：**你用的最多的智能指针是哪一个，`unique_ptr<T> ` 和 `shared_ptr<T>` 你会分别在什么情况下使用？



**问题14：**关于 c++11 的线程同步问题，说一下你使用最多的线程同步方式？



**问题15：**`atomic` 有使用过吗，它的作用是什么？



**问题16：**综合问题 14 和 15，谈谈你对条件变量的理解，对比 `atomic`，使用互斥锁和条件变量的优势是什么，亦或者是说，两者的使用场景是什么？

这个问题我只能尝试性的回答，因为 `atomic` 使用的非常少。



**问题17：**多进程有使用过吗？



**问题18：**知道哪些设计模式？



## 手撕题目

求两个 int 类型整数的平均值，不能借用取值更大的类型来进行相加。

> 问题本质：两个符号相同的数相加，会出现溢出，分两种情况：
>
> - 符号不同，直接相加除2就可以了（此时一定不会溢出）；
>
> - 符号相同，两个数相减，得到差值，较小的数加上差值的一半，即得到平均数。



## 拓展

**拓展1：**从源码的角度剖析 `shared_ptr<T>` 智能指针循环引用的问题。

```c++
struct ControlBlock {
    size_t shared_count; // 共享引用计数
    size_t weak_count;   // 弱引用计数
    Deleter deleter;     // 删除器
};

template<typename T>
class shared_ptr {
    T* ptr;              // 原始指针
    ControlBlock* ctrl;  // 共享控制块
    
    // 引用计数增加，浅拷贝构造
    shared_ptr(const shared_ptr& other) {
        ctrl = other.ctrl;		// 控制块在内存中只有一份
        ++ctrl->shared_count;
    }

    // 引用计数减少，析构函数（对应浅拷贝）
    ~shared_ptr() {
        if (--ctrl->shared_count == 0) {
            delete ptr;		// object destructor

            if (ctrl->weak_count == 0) {
                delete ctrl;	// ControlBlock destructor
            }
        }
    }
};

struct Node {
    std::shared_ptr<Node> next;
};

int main(){
    // new source
    auto node1 = std::make_shared<Node>();
    auto node2 = std::make_shared<Node>();
    
    node1->next = node2;
    node2->next = node1;
    
    return 0;
}
```

上述代码 `main()` 函数执行结束后，析构函数的执行流程如下：

> - 先执行 `node2` 的析构函数，由于 `--ctrl->shared_count == 1`，所以 `Node` 对象不会执行析构函数，`next` 的析构函数不会执行，不会存在 `--ctrl->shared_count == 0` 的情况；
> - 同理，执行 `node1` 的析构函数，由于 `--ctrl->shared_count == 1`，所以 `Node` 对象不会执行析构函数，`next` 的析构函数不会执行，不会存在 `--ctrl->shared_count == 0` 的情况；
>
> 这就导致了 Node 对象一直存在于堆区内存中，造成内存泄漏。

**拓展2：**从源码角度剖析，如何使用 `weak_ptr<T>` 解决循环引用问题？

```c++
template<typename T>
class weak_ptr {
    T* ptr;              // 原始指针
    ControlBlock* ctrl;  // 共享控制块
    
	// constructor
    weak_ptr(const shared_ptr<T>& sp) noexcept {
        ptr = sp.ptr;
        ctrl = sp.ctrl;
        
        if (ctrl) {
            ++ctrl->weak_count; // 只增加弱引用计数
        }
    }
    
    // destructor
    ~weak_ptr() {
        if (ctrl) {
            if (--ctrl->weak_count == 0 && ctrl->shared_count == 0) {
                delete ctrl;
            }
        }
    }
};
```

`weak_ptr<T>` 通过只对 `ControlBlock.weak_count` 操作，解决了循环引用问题，使得 `shared_ptr<T>` 指向的对象可以正常的执行其析构函数。 

注意：

