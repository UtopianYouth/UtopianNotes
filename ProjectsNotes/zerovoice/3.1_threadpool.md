# 线程池

## 项目描述

该项目属于基础组件。线程池本身没有实现线程安全，而是通过对 STL 中非线程安全的 `queue<T>` 进行了封装，封装好的 `BlockingQueue<T>` 和 `BlockingQueuePro<T>` 是线程安全的，线程池基于线程安全的数据结构来实现业务逻辑处理的。

<font color = red>线程池和线程安全的阻塞队列均已实现了泛化，可以使用到不同的业务场景中</font>。

## 运行

`example.cpp` 是基于线程池实现的生产者消费者模型，其中，生产者线程 4 个，产生 10 个任务，线程池中的线程数量 2 个，为消费者线程，执行 40 个工作任务。

```c++
// 1. 执行 make 命令生成 example 可执行文件
// 2. 通过打印记录，得到运行结果
```

## 技术栈

c++11多线程，互斥锁，条件变量，智能指针等新特性。

## 优化部分

> **问题：**针对`BlockingQueue<T>`实现的工作队列，生产者和消费者同时竞争一个互斥锁，操作该数据结构。
>
> **优化：**减小锁的细粒度，封装 `BlockingQueuePro` 类，将生产者和消费者线程操作的队列进行分离。

**值得思考的细节**

> 面向生产者线程
>
> - 发布任务到线程池；
>
> 线程池的大体框架
>
> - 为什么使用队列？
> - 任务如何抽象？
> - 线程数量的选择？
>
> 阻塞队列设计（线程安全）
>
> - 互斥锁和条件变量的作用；
>
> 优化：使用双队列减小锁的细粒度，提高并发性能
>
> - 交换队列（`int SwapQueue(){}`）的实现细节；
>
> 工作线程的入口函数实现
>
> 线程池销毁逻辑（阻塞队列不再阻塞）
>
> 阻塞队列和线程池封装分离
>
> 前置声明代替头文件包含，避免循环依赖 ==> 大项目经常需要注意的点