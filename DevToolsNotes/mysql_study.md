# MySQL入门

## 一、索引相关

**MySQL的索引为什么不用hash，而是使用B+树呢，hash的查找时间复杂度更低？**

> 场景：我们需要select多条已经排序好的数据？
>
> 首先，hash表中的数据只支持一次加载到内存中，而MySQL的索引是存储在磁盘中的，对于海量数据，可能导致无法将全部的索引加载到内存中，也就无法使用Hash了；
>
> 这样的话，就只能考虑使用B树和B+树了，但是B树对于批量查找有序的数据，会造成多次遍历B树，跨层访问，对于n个有序的数据，时间复杂度为：`O(n*logn)`；
>
> 所以，B树不行，使用B+树，B+树是对B树的优化，所有数据存储在叶子节点上，叶子节点通过链表链接起来了，这样对于查找批量有序的数据，我们就可以不用像B树一样，跨层多次访问了，对于n个有序的数据，时间复杂度为：`O(logn + n)`；

> 拓展：B树应用在文件索引中，那么文件索引为什么不使用二叉搜索树或者是B+树呢？
>
> **首先为什么不使用二叉搜索树**：二叉树在内存中效率很高，但因为其“瘦高”的特性，会导致过多的磁盘I/O，完全不适合磁盘索引的场景。B树通过“矮胖”的结构，极大地减少了I/O次数，是专为磁盘等外部存储设备设计的数据结构。
>
> | 特性           | 二叉树（包括AVL树、红黑树等）                                | B树                                                          |
> | :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | **树的高度**   | 高。一个节点只存一个键和两个指针，树是“瘦高”的。             | 矮。一个节点可以存放大量键和指针（比如几百个），树是“矮胖”的。 |
> | **磁盘I/O**    | 查找一个键可能需要O(log₂N)次磁盘I/O。对于十亿量级的数据，树高约30，需要几十次I/O，无法接受。 | 查找一个键通常只需要O(logₘN)次I/O（m是阶数，很大）。对于十亿量级的数据，树高通常只有3-4层，仅需3-4次I/O。 |
> | **局部性原理** | 差。每次读取一个节点（包含少量数据）可能都需要一次磁盘I/O，且节点在磁盘上不连续，无法利用预读。 | 好。B树的一个节点大小被设计为等于一个磁盘页（如4KB）。一次I/O可以读入大量键，并利用磁盘的预读特性（预读相邻数据）。 |
>
> **然后是为什么文件索引不使用B+树呢？**
>
> 在现代数据库系统中，主流的索引实现其实是B+树，而不是B树，但是文件系统（如早期的NTFS）的索引确实使用了B树，这背后的原因是查询模式的不同。
>
> - **查询以“点查询”为主**：大部分操作是根据文件名（一个具体的键）来查找文件的元数据（inode）。这种查询在B树中可能更快，因为可能在非叶子节点就命中结果；
>
> - **文件系统事务性要求较低**：B+树的叶子节点链表结构在范围查询和全顺序扫描上有巨大优势，但这在数据库（频繁做表扫描、范围查询）中更重要。对于文件系统，遍历整个目录的需求相对较少；
>
> - **实现复杂性**：在某些场景下，B树的实现可能相对B+树稍简单一些（尽管现代数据库已经证明B+树的实现非常成熟）。
>
> | 特性                  | B树                                                          | B+树                                                         |
> | :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
> | **数据存储位置**      | **每个节点都存放数据**（键和对应的数据记录或指针）。         | **只有叶子节点存放数据**，非叶子节点只起索引作用（只存放键和指向子节点的指针）。 |
> | **叶子节点链接**      | 叶子节点之间**没有**指针链接。                               | 所有叶子节点通过指针形成一个**有序双向链表**。               |
> | **查找性能**          | 最好的情况是，在根节点或靠近根节点的节点就找到数据，查询很快。 | 任何查找都必须走到叶子节点，性能**稳定**。                   |
> | **范围查询/全盘扫描** | 效率低。需要进行中序遍历。                                   | 效率极高。找到范围下限后，沿叶子节点链表顺序扫描即可。       |



**什么是普通索引，主键索引？**

> 核心区别：普通索引叶子结点存放主键值，主键索引叶子节点存放数据行（针对InnoDB引擎）。
>
> | 特性     | 普通索引     | 主键索引     |
> | :------- | :----------- | :----------- |
> | 唯一性   | 不保证唯一   | 保证唯一     |
> | NULL值   | 允许         | 不允许       |
> | 数量限制 | 可创建多个   | 每表只能一个 |
> | 是否聚簇 | 否（InnoDB） | 是（InnoDB） |
> | 创建语法 | INDEX/KEY    | PRIMARY KEY  |



**覆盖索引，回表和最左匹配原则？**

> **覆盖索引**：覆盖索引是指一个索引包含了查询所需的所有字段（即select后面的所有字段都是复合索引的内容），MySQL可以直接从索引中获取数据，而不需要回表查询数据行。
>
> **回表**：当索引不包含查询所需的所有字段时（即select后面的字段不全部包含在where对应的索引中），MySQL需要根据索引找到的主键值，**回到主键索引（聚簇索引）中查找完整数据行**的过程。
>
> **最左匹配原则**：对于复合索引（多列索引），MySQL会从左到右依次匹配索引列。查询条件必须包含索引的最左列，才能有效使用该索引。
>
> | 概念         | 核心要点                 | 优化建议                   |
> | :----------- | :----------------------- | :------------------------- |
> | **覆盖索引** | 索引包含所有查询字段     | 将SELECT字段加入索引       |
> | **回表**     | 二级索引→主键索引→数据行 | 尽量减少回表次数           |
> | **最左匹配** | 复合索引从左到右匹配     | 将高频查询条件放在索引左侧 |



**MyISAM与InnoDB的索引，主要的差异是什么？**

> **非聚簇与聚簇的区别**：一个叶子节点内容是存储数据文件的指针，一个叶子节点内容存储数据行。
>
> | 特性             | MyISAM               | InnoDB                               |
> | :--------------- | :------------------- | :----------------------------------- |
> | **索引类型**     | 全部是非聚簇索引     | 主键是聚簇索引，二级索引是非聚簇索引 |
> | **数据存储**     | 数据与索引分离存储   | 数据按主键顺序存储在聚簇索引中       |
> | **叶子节点内容** | 存储数据文件指针     | 主键索引存数据行，二级索引存主键值   |
> | **主键要求**     | 可以有非唯一主键     | 主键必须唯一，如未指定会自动生成     |
> | **回表操作**     | 所有索引都需要"回表" | 只有二级索引需要回表到聚簇索引       |
> | **索引查询效率** | 所有索引访问速度一致 | 主键索引极快，二级索引相对较慢       |



## 二、锁相关

什么是行锁、表锁和全局锁？



InnoDB的七种锁？



一条SQL执行很慢的原因有哪些？



为什么我改一行的语句，锁会这么多？



幻读是什么，幻读有什么问题？



## 三、日志与事务

一条SQL更新语句是如何执行的？